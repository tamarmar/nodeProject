/*! @hebcal/core v4.1.1 */
'use strict';

/*
 * More minimal greg routines
 */

/** @private */
const lengths = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
/** @private */
const monthLengths = [lengths, lengths.slice()];
monthLengths[1][2] = 29;

/**
 * @private
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
function mod(x, y) {
  return x - y * Math.floor(x / y);
}

/**
 * @private
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
function quotient(x, y) {
  return Math.floor(x / y);
}

/**
 * Returns true if the Gregorian year is a leap year
 * @private
 * @param {number} year Gregorian year
 * @return {boolean}
 */
function isLeapYear$1(year) {
  return !(year % 4) && (!!(year % 100) || !(year % 400));
}

/**
 * Number of days in the Gregorian month for given year
 * @private
 * @param {number} month Gregorian month (1=January, 12=December)
 * @param {number} year Gregorian year
 * @return {number}
 */
function daysInMonth$1(month, year) {
  // 1 based months
  return monthLengths[+isLeapYear$1(year)][month];
}

/**
 * Returns true if the object is a Javascript Date
 * @private
 * @param {Object} obj
 * @return {boolean}
 */
function isDate(obj) {
  return typeof obj === 'object' && Date.prototype === obj.__proto__;
}

/*
const ABS_14SEP1752 = 639797;
const ABS_2SEP1752 = 639785;
*/

/**
 * Converts Gregorian date to absolute R.D. (Rata Die) days
 * @private
 * @param {Date} date Gregorian date
 * @return {number}
 */
function greg2abs(date) {
  if (!isDate(date)) {
    throw new TypeError(`Argument not a Date: ${date}`);
  }
  const abs = toFixed(date.getFullYear(), date.getMonth() + 1, date.getDate());
  /*
  if (abs < ABS_14SEP1752 && abs > ABS_2SEP1752) {
    throw new RangeError(`Invalid Date: ${date}`);
  }
  */
  return abs;
}

/**
 * @private
 * @param {number} abs - R.D. number of days
 * @return {number}
 */
function yearFromFixed(abs) {
  const l0 = abs - 1;
  const n400 = quotient(l0, 146097);
  const d1 = mod(l0, 146097);
  const n100 = quotient(d1, 36524);
  const d2 = mod(d1, 36524);
  const n4 = quotient(d2, 1461);
  const d3 = mod(d2, 1461);
  const n1 = quotient(d3, 365);
  const year = 400 * n400 + 100 * n100 + 4 * n4 + n1;
  return n100 != 4 && n1 != 4 ? year + 1 : year;
}

/**
 * @private
 * @param {number} year
 * @param {number} month (1-12)
 * @param {number} day (1-31)
 * @return {number}
 */
function toFixed(year, month, day) {
  const py = year - 1;
  return 365 * py + quotient(py, 4) - quotient(py, 100) + quotient(py, 400) + quotient(367 * month - 362, 12) + (month <= 2 ? 0 : isLeapYear$1(year) ? -1 : -2) + day;
}

/**
 * Converts from Rata Die (R.D. number) to Gregorian date.
 * See the footnote on page 384 of ``Calendrical Calculations, Part II:
 * Three Historical Calendars'' by E. M. Reingold,  N. Dershowitz, and S. M.
 * Clamen, Software--Practice and Experience, Volume 23, Number 4
 * (April, 1993), pages 383-404 for an explanation.
 * @private
 * @param {number} abs - R.D. number of days
 * @return {Date}
 */
function abs2greg(abs) {
  if (typeof abs !== 'number') {
    throw new TypeError(`Argument not a Number: ${abs}`);
  }
  abs = Math.trunc(abs);
  /*
  if (abs < ABS_14SEP1752 && abs > ABS_2SEP1752) {
    throw new RangeError(`Invalid Date: ${abs}`);
  }
  */
  const year = yearFromFixed(abs);
  const priorDays = abs - toFixed(year, 1, 1);
  const correction = abs < toFixed(year, 3, 1) ? 0 : isLeapYear$1(year) ? 1 : 2;
  const month = quotient(12 * (priorDays + correction) + 373, 367);
  const day = abs - toFixed(year, month, 1) + 1;
  const dt = new Date(year, month - 1, day);
  if (year < 100 && year >= 0) {
    dt.setFullYear(year);
  }
  return dt;
}

/*
    Hebcal - A Jewish Calendar Generator
    Copyright (c) 1994-2020 Danny Sadinoff
    Portions copyright Eyal Schachter and Michael J. Radwin

    https://github.com/hebcal/hebcal-es6

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * Gregorian date helper functions.
 */
const greg = {
  /**
   * Long names of the Gregorian months (1='January', 12='December')
   * @readonly
   * @type {string[]}
   */
  monthNames: ['', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
  /**
   * Returns true if the Gregorian year is a leap year
   * @function
   * @param {number} year Gregorian year
   * @return {boolean}
   */
  isLeapYear: isLeapYear$1,
  /**
   * Number of days in the Gregorian month for given year
   * @function
   * @param {number} month Gregorian month (1=January, 12=December)
   * @param {number} year Gregorian year
   * @return {number}
   */
  daysInMonth: daysInMonth$1,
  /**
   * Returns true if the object is a Javascript Date
   * @function
   * @param {Object} obj
   * @return {boolean}
   */
  isDate: isDate,
  /**
   * Returns number of days since January 1 of that year
   * @deprecated
   * @param {Date} date Gregorian date
   * @return {number}
   */
  dayOfYear: function (date) {
    if (!isDate(date)) {
      throw new TypeError(`Argument not a Date: ${date}`);
    }
    const month = date.getMonth();
    let doy = date.getDate() + 31 * month;
    if (month > 1) {
      // FEB
      doy -= Math.floor((4 * (month + 1) + 23) / 10);
      if (isLeapYear$1(date.getFullYear())) {
        doy++;
      }
    }
    return doy;
  },
  /**
   * Converts Gregorian date to absolute R.D. (Rata Die) days
   * @function
   * @param {Date} date Gregorian date
   * @return {number}
   */
  greg2abs: greg2abs,
  /**
   * Converts from Rata Die (R.D. number) to Gregorian date.
   * See the footnote on page 384 of ``Calendrical Calculations, Part II:
   * Three Historical Calendars'' by E. M. Reingold,  N. Dershowitz, and S. M.
   * Clamen, Software--Practice and Experience, Volume 23, Number 4
   * (April, 1993), pages 383-404 for an explanation.
   * @function
   * @param {number} theDate - R.D. number of days
   * @return {Date}
   */
  abs2greg: abs2greg
};

const GERESH = '׳';
const GERSHAYIM = '״';

/**
 * @private
 * @param {number} num
 * @return {string}
 */
function num2heb(num) {
  switch (num) {
    case 1:
      return 'א';
    case 2:
      return 'ב';
    case 3:
      return 'ג';
    case 4:
      return 'ד';
    case 5:
      return 'ה';
    case 6:
      return 'ו';
    case 7:
      return 'ז';
    case 8:
      return 'ח';
    case 9:
      return 'ט';
    case 10:
      return 'י';
    case 20:
      return 'כ';
    case 30:
      return 'ל';
    case 40:
      return 'מ';
    case 50:
      return 'נ';
    case 60:
      return 'ס';
    case 70:
      return 'ע';
    case 80:
      return 'פ';
    case 90:
      return 'צ';
    case 100:
      return 'ק';
    case 200:
      return 'ר';
    case 300:
      return 'ש';
    case 400:
      return 'ת';
    default:
      return '*INVALID*';
  }
}

/**
 * @private
 * @param {number} num
 * @return {number[]}
 */
function num2digits(num) {
  const digits = [];
  while (num > 0) {
    if (num === 15 || num === 16) {
      digits.push(9);
      digits.push(num - 9);
      break;
    }
    let incr = 100;
    let i;
    for (i = 400; i > num; i -= incr) {
      if (i === incr) {
        incr = incr / 10;
      }
    }
    digits.push(i);
    num -= i;
  }
  return digits;
}

/**
 * Converts a numerical value to a string of Hebrew letters.
 *
 * When specifying years of the Hebrew calendar in the present millennium,
 * we omit the thousands (which is presently 5 [ה]).
 * @example
 * gematriya(5774) // 'תשע״ד' - cropped to 774
 * gematriya(25) // 'כ״ה'
 * gematriya(60) // 'ס׳'
 * gematriya(3761) // 'ג׳תשס״א'
 * gematriya(1123) // 'א׳קכ״ג'
 * @param {number} number
 * @return {string}
 */
function gematriya(number) {
  const num = parseInt(number, 10);
  if (!num) {
    throw new TypeError(`invalid parameter to gematriya ${number}`);
  }
  let str = '';
  const thousands = Math.floor(num / 1000);
  if (thousands > 0 && thousands !== 5) {
    const tdigits = num2digits(thousands);
    for (let i = 0; i < tdigits.length; i++) {
      str += num2heb(tdigits[i]);
    }
    str += GERESH;
  }
  const digits = num2digits(num % 1000);
  if (digits.length == 1) {
    return str + num2heb(digits[0]) + GERESH;
  }
  for (let i = 0; i < digits.length; i++) {
    if (i + 1 === digits.length) {
      str += GERSHAYIM;
    }
    str += num2heb(digits[i]);
  }
  return str;
}

const noopLocale = {
  headers: {
    'plural-forms': 'nplurals=2; plural=(n!=1);'
  },
  contexts: {
    '': {}
  }
};
const alias = {
  'h': 'he',
  'a': 'ashkenazi',
  's': 'en',
  '': 'en'
};

/** @private */
const locales = Object.create(null);
/** @private */
let activeLocale = null;
/** @private */
let activeName = null;

/**
 * A locale in Hebcal is used for translations/transliterations of
 * holidays. `@hebcal/core` supports four locales by default
 * * `en` - default, Sephardic transliterations (e.g. "Shabbat")
 * * `ashkenazi` - Ashkenazi transliterations (e.g. "Shabbos")
 * * `he` - Hebrew (e.g. "שַׁבָּת")
 * * `he-x-NoNikud` - Hebrew without nikud (e.g. "שבת")
 */
class Locale {
  /**
   * Returns translation only if `locale` offers a non-empty translation for `id`.
   * Otherwise, returns `undefined`.
   * @param {string} id Message ID to translate
   * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
   * @return {string}
   */
  static lookupTranslation(id, locale) {
    const locale0 = locale && locale.toLowerCase();
    const loc = typeof locale == 'string' && locales[locale0] || activeLocale;
    const array = loc[id];
    if (array && array.length && array[0].length) {
      return array[0];
    }
    return undefined;
  }

  /**
   * By default, if no translation was found, returns `id`.
   * @param {string} id Message ID to translate
   * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
   * @return {string}
   */
  static gettext(id, locale) {
    const text = this.lookupTranslation(id, locale);
    if (typeof text == 'undefined') {
      return id;
    }
    return text;
  }

  /**
   * Register locale translations.
   * @param {string} locale Locale name (i.e.: `'he'`, `'fr'`)
   * @param {LocaleData} data parsed data from a `.po` file.
   */
  static addLocale(locale, data) {
    if (typeof locale !== 'string') {
      throw new TypeError(`Invalid locale name: ${locale}`);
    }
    if (typeof data.contexts !== 'object' || typeof data.contexts[''] !== 'object') {
      throw new TypeError(`Locale '${locale}' invalid compact format`);
    }
    locales[locale.toLowerCase()] = data.contexts[''];
  }

  /**
   * Adds a translation to `locale`, replacing any previous translation.
   * @param {string} locale Locale name (i.e: `'he'`, `'fr'`).
   * @param {string} id Message ID to translate
   * @param {string} translation Translation text
   */
  static addTranslation(locale, id, translation) {
    if (typeof locale !== 'string') {
      throw new TypeError(`Invalid locale name: ${locale}`);
    }
    const locale0 = locale.toLowerCase();
    const loc = locales[locale0];
    if (!loc) {
      throw new TypeError(`Unknown locale: ${locale}`);
    }
    if (typeof id !== 'string' || id.length === 0) {
      throw new TypeError(`Invalid id: ${id}`);
    }
    const isArray = Array.isArray(translation);
    if (isArray) {
      const t0 = translation[0];
      if (typeof t0 !== 'string' || t0.length === 0) {
        throw new TypeError(`Invalid translation array: ${translation}`);
      }
    } else if (typeof translation !== 'string') {
      throw new TypeError(`Invalid translation: ${translation}`);
    }
    loc[id] = isArray ? translation : [translation];
  }
  /**
   * Adds multiple translations to `locale`, replacing any previous translations.
   * @param {string} locale Locale name (i.e: `'he'`, `'fr'`).
   * @param {LocaleData} data parsed data from a `.po` file.
   */
  static addTranslations(locale, data) {
    if (typeof locale !== 'string') {
      throw new TypeError(`Invalid locale name: ${locale}`);
    }
    const locale0 = locale.toLowerCase();
    const loc = locales[locale0];
    if (!loc) {
      throw new TypeError(`Unknown locale: ${locale}`);
    }
    if (typeof data.contexts !== 'object' || typeof data.contexts[''] !== 'object') {
      throw new TypeError(`Locale '${locale}' invalid compact format`);
    }
    const ctx = data.contexts[''];
    Object.keys(ctx).forEach(id => {
      loc[id] = ctx[id];
    });
  }
  /**
   * Activates a locale. Throws an error if the locale has not been previously added.
   * After setting the locale to be used, all strings marked for translations
   * will be represented by the corresponding translation in the specified locale.
   * @param {string} locale Locale name (i.e: `'he'`, `'fr'`)
   * @return {LocaleData}
   */
  static useLocale(locale) {
    const locale0 = locale.toLowerCase();
    const obj = locales[locale0];
    if (!obj) {
      throw new RangeError(`Locale '${locale}' not found`);
    }
    activeName = alias[locale0] || locale0;
    activeLocale = obj;
    return activeLocale;
  }

  /**
   * Returns the name of the active locale (i.e. 'he', 'ashkenazi', 'fr')
   * @return {string}
   */
  static getLocaleName() {
    return activeName;
  }

  /**
   * Returns the names of registered locales
   * @return {string[]}
   */
  static getLocaleNames() {
    return Object.keys(locales).sort();
  }

  /**
   * @param {number} n
   * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
   * @return {string}
   */
  static ordinal(n, locale) {
    const locale1 = locale && locale.toLowerCase();
    const locale0 = locale1 || activeName;
    if (!locale0) {
      return this.getEnOrdinal(n);
    }
    switch (locale0) {
      case 'en':
      case 's':
      case 'a':
      case 'ashkenazi':
      case 'ashkenazi_litvish':
      case 'ashkenazi_poylish':
      case 'ashkenazi_standard':
        return this.getEnOrdinal(n);
      case 'es':
        return n + 'º';
      case 'h':
      case 'he':
      case 'he-x-nonikud':
        return String(n);
      default:
        return n + '.';
    }
  }

  /**
   * @private
   * @param {number} n
   * @return {string}
   */
  static getEnOrdinal(n) {
    const s = ['th', 'st', 'nd', 'rd'];
    const v = n % 100;
    return n + (s[(v - 20) % 10] || s[v] || s[0]);
  }

  /**
   * Removes nekudot from Hebrew string
   * @param {string} str
   * @return {string}
   */
  static hebrewStripNikkud(str) {
    return str.replace(/[\u0590-\u05bd]/g, '').replace(/[\u05bf-\u05c7]/g, '');
  }
}
Locale.addLocale('en', noopLocale);
Locale.addLocale('s', noopLocale);
Locale.addLocale('', noopLocale);
Locale.useLocale('en');

/*
 * More minimal HDate
 */

const NISAN$4 = 1;
const IYYAR$1 = 2;
// const SIVAN = 3;
const TAMUZ$1 = 4;
// const AV = 5;
const ELUL$2 = 6;
const TISHREI$2 = 7;
const CHESHVAN$1 = 8;
const KISLEV$2 = 9;
const TEVET$2 = 10;
// const SHVAT = 11;
const ADAR_I$2 = 12;
const ADAR_II$1 = 13;

/**
 * Hebrew months of the year (NISAN=1, TISHREI=7)
 * @readonly
 * @enum {number}
 */
const months = {
  /** Nissan / ניסן */
  NISAN: 1,
  /** Iyyar / אייר */
  IYYAR: 2,
  /** Sivan / סיון */
  SIVAN: 3,
  /** Tamuz (sometimes Tammuz) / תמוז */
  TAMUZ: 4,
  /** Av / אב */
  AV: 5,
  /** Elul / אלול */
  ELUL: 6,
  /** Tishrei / תִשְׁרֵי */
  TISHREI: 7,
  /** Cheshvan / חשון */
  CHESHVAN: 8,
  /** Kislev / כסלו */
  KISLEV: 9,
  /** Tevet / טבת */
  TEVET: 10,
  /** Sh'vat / שבט */
  SHVAT: 11,
  /** Adar or Adar Rishon / אדר */
  ADAR_I: 12,
  /** Adar Sheini (only on leap years) / אדר ב׳ */
  ADAR_II: 13
};
const monthNames0 = ['', 'Nisan', 'Iyyar', 'Sivan', 'Tamuz', 'Av', 'Elul', 'Tishrei', 'Cheshvan', 'Kislev', 'Tevet', 'Sh\'vat'];

/**
 * Transliterations of Hebrew month names.
 * Regular years are index 0 and leap years are index 1.
 * @private
 */
const monthNames = [monthNames0.concat(['Adar', 'Nisan']), monthNames0.concat(['Adar I', 'Adar II', 'Nisan'])];
const edCache = Object.create(null);
const EPOCH = -1373428;
// Avg year length in the cycle (19 solar years with 235 lunar months)
const AVG_HEBYEAR_DAYS = 365.24682220597794;

/**
 * @private
 * @param {any} n
 * @param {string} name
 */
function assertNumber(n, name) {
  if (typeof n !== 'number' || isNaN(n)) {
    throw new TypeError(`invalid parameter '${name}' not a number: ${n}`);
  }
}

/**
 * Converts Hebrew date to R.D. (Rata Die) fixed days.
 * R.D. 1 is the imaginary date Monday, January 1, 1 on the Gregorian
 * Calendar.
 * @private
 * @param {number} year Hebrew year
 * @param {number} month Hebrew month
 * @param {number} day Hebrew date (1-30)
 * @return {number}
 */
function hebrew2abs(year, month, day) {
  assertNumber(year, 'year');
  assertNumber(month, 'month');
  assertNumber(day, 'day');
  if (year < 1) {
    throw new RangeError(`hebrew2abs: invalid year ${year}`);
  }
  let tempabs = day;
  if (month < TISHREI$2) {
    for (let m = TISHREI$2; m <= monthsInYear(year); m++) {
      tempabs += daysInMonth(m, year);
    }
    for (let m = NISAN$4; m < month; m++) {
      tempabs += daysInMonth(m, year);
    }
  } else {
    for (let m = TISHREI$2; m < month; m++) {
      tempabs += daysInMonth(m, year);
    }
  }
  return EPOCH + elapsedDays(year) + tempabs - 1;
}

/**
 * @private
 * @param {number} year
 * @return {number}
 */
function newYear(year) {
  return EPOCH + elapsedDays(year);
}

/**
 * Converts absolute R.D. days to Hebrew date
 * @private
 * @param {number} abs absolute R.D. days
 * @return {SimpleHebrewDate}
 */
function abs2hebrew(abs) {
  assertNumber(abs, 'abs');
  abs = Math.trunc(abs);
  if (abs <= EPOCH) {
    throw new RangeError(`abs2hebrew: ${abs} is before epoch`);
  }
  // first, quickly approximate year
  let year = Math.floor((abs - EPOCH) / AVG_HEBYEAR_DAYS);
  while (newYear(year) <= abs) {
    ++year;
  }
  --year;
  let month = abs < hebrew2abs(year, 1, 1) ? 7 : 1;
  while (abs > hebrew2abs(year, month, daysInMonth(month, year))) {
    ++month;
  }
  const day = 1 + abs - hebrew2abs(year, month, 1);
  return {
    yy: year,
    mm: month,
    dd: day
  };
}

/**
 * Returns true if Hebrew year is a leap year
 * @private
 * @param {number} year Hebrew year
 * @return {boolean}
 */
function isLeapYear(year) {
  return (1 + year * 7) % 19 < 7;
}

/**
 * Number of months in this Hebrew year (either 12 or 13 depending on leap year)
 * @private
 * @param {number} year Hebrew year
 * @return {number}
 */
function monthsInYear(year) {
  return 12 + isLeapYear(year); // boolean is cast to 1 or 0
}

/**
 * Number of days in Hebrew month in a given year (29 or 30)
 * @private
 * @param {number} month Hebrew month (e.g. months.TISHREI)
 * @param {number} year Hebrew year
 * @return {number}
 */
function daysInMonth(month, year) {
  switch (month) {
    case IYYAR$1:
    case TAMUZ$1:
    case ELUL$2:
    case TEVET$2:
    case ADAR_II$1:
      return 29;
  }
  if (month === ADAR_I$2 && !isLeapYear(year) || month === CHESHVAN$1 && !longCheshvan(year) || month === KISLEV$2 && shortKislev(year)) {
    return 29;
  } else {
    return 30;
  }
}

/**
 * Returns a transliterated string name of Hebrew month in year,
 * for example 'Elul' or 'Cheshvan'.
 * @private
 * @param {number} month Hebrew month (e.g. months.TISHREI)
 * @param {number} year Hebrew year
 * @return {string}
 */
function getMonthName(month, year) {
  assertNumber(month, 'month');
  assertNumber(year, 'year');
  if (month < 1 || month > 14) {
    throw new TypeError(`bad month argument ${month}`);
  }
  return monthNames[+isLeapYear(year)][month];
}

/**
 * Days from sunday prior to start of Hebrew calendar to mean
 * conjunction of Tishrei in Hebrew YEAR
 * @private
 * @param {number} year Hebrew year
 * @return {number}
 */
function elapsedDays(year) {
  const elapsed = edCache[year] = edCache[year] || elapsedDays0(year);
  return elapsed;
}

/**
 * Days from sunday prior to start of Hebrew calendar to mean
 * conjunction of Tishrei in Hebrew YEAR
 * @private
 * @param {number} year Hebrew year
 * @return {number}
 */
function elapsedDays0(year) {
  const prevYear = year - 1;
  const mElapsed = 235 * Math.floor(prevYear / 19) +
  // Months in complete 19 year lunar (Metonic) cycles so far
  12 * (prevYear % 19) +
  // Regular months in this cycle
  Math.floor((prevYear % 19 * 7 + 1) / 19); // Leap months this cycle

  const pElapsed = 204 + 793 * (mElapsed % 1080);
  const hElapsed = 5 + 12 * mElapsed + 793 * Math.floor(mElapsed / 1080) + Math.floor(pElapsed / 1080);
  const parts = pElapsed % 1080 + 1080 * (hElapsed % 24);
  const day = 1 + 29 * mElapsed + Math.floor(hElapsed / 24);
  const altDay = day + (parts >= 19440 || 2 === day % 7 && parts >= 9924 && !isLeapYear(year) || 1 === day % 7 && parts >= 16789 && isLeapYear(prevYear));
  return altDay + (altDay % 7 === 0 || altDay % 7 === 3 || altDay % 7 === 5);
}

/**
 * Number of days in the hebrew YEAR.
 * A common Hebrew calendar year can have a length of 353, 354 or 355 days
 * A leap Hebrew calendar year can have a length of 383, 384 or 385 days
 * @private
 * @param {number} year Hebrew year
 * @return {number}
 */
function daysInYear(year) {
  return elapsedDays(year + 1) - elapsedDays(year);
}

/**
 * true if Cheshvan is long in Hebrew year
 * @private
 * @param {number} year Hebrew year
 * @return {boolean}
 */
function longCheshvan(year) {
  return daysInYear(year) % 10 === 5;
}

/**
 * true if Kislev is short in Hebrew year
 * @private
 * @param {number} year Hebrew year
 * @return {boolean}
 */
function shortKislev(year) {
  return daysInYear(year) % 10 === 3;
}

/**
 * @private
 * @param {string} msg
 */
function throwTypeError(msg) {
  throw new TypeError(msg);
}

/*
    Hebcal - A Jewish Calendar Generator
    Copyright (c) 1994-2020 Danny Sadinoff
    Portions copyright Eyal Schachter and Michael J. Radwin

    https://github.com/hebcal/hebcal-es6

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
const UNITS_DAY = 'day';
const UNITS_WEEK = 'week';
const UNITS_MONTH = 'month';
const UNITS_YEAR = 'year';
const UNITS_SINGLE = {
  d: UNITS_DAY,
  w: UNITS_WEEK,
  M: UNITS_MONTH,
  y: UNITS_YEAR
};
const UNITS_VALID = {
  day: UNITS_DAY,
  week: UNITS_WEEK,
  month: UNITS_MONTH,
  year: UNITS_YEAR
};

/**
 * A simple Hebrew date object with numeric fields `yy`, `mm`, and `dd`
 * @typedef {Object} SimpleHebrewDate
 * @property {number} yy Hebrew year
 * @property {number} mm Hebrew month of year (1=NISAN, 7=TISHREI)
 * @property {number} dd Day of month (1-30)
 * @private
 */

/** Represents a Hebrew date */
class HDate {
  /**
   * Create a Hebrew date. There are 3 basic forms for the `HDate()` constructor.
   *
   * 1. No parameters - represents the current Hebrew date at time of instantiation
   * 2. One parameter
   *    * `Date` - represents the Hebrew date corresponding to the Gregorian date using
   *       local time. Hours, minutes, seconds and milliseconds are ignored.
   *    * `HDate` - clones a copy of the given Hebrew date
   *    * `number` - Converts absolute R.D. days to Hebrew date.
   *       R.D. 1 == the imaginary date January 1, 1 (Gregorian)
   * 3. Three parameters: Hebrew day, Hebrew month, Hebrew year. Hebrew day should
   *    be a number between 1-30, Hebrew month can be a number or string, and
   *    Hebrew year is always a number.
   * @example
   * import {HDate, months} from '@hebcal/core';
   *
   * const hd1 = new HDate();
   * const hd2 = new HDate(new Date(2008, 10, 13));
   * const hd3 = new HDate(15, 'Cheshvan', 5769);
   * const hd4 = new HDate(15, months.CHESHVAN, 5769);
   * const hd5 = new HDate(733359); // ==> 15 Cheshvan 5769
   * const monthName = 'אייר';
   * const hd6 = new HDate(5, monthName, 5773);
   * @param {number|Date|HDate} [day] - Day of month (1-30) if a `number`.
   *   If a `Date` is specified, represents the Hebrew date corresponding to the
   *   Gregorian date using local time.
   *   If an `HDate` is specified, clones a copy of the given Hebrew date.
   * @param {number|string} [month] - Hebrew month of year (1=NISAN, 7=TISHREI)
   * @param {number} [year] - Hebrew year
   */
  constructor(day, month, year) {
    if (arguments.length == 2 || arguments.length > 3) {
      throw new TypeError('HDate constructor requires 0, 1 or 3 arguments');
    }
    if (arguments.length == 3) {
      // Hebrew day, Hebrew month, Hebrew year
      /**
       * @private
       * @type {number}
       */
      this.day = this.month = 1;
      /**
       * @private
       * @type {number}
       */
      year = parseInt(year, 10);
      if (isNaN(year)) {
        throw new TypeError(`HDate called with bad year argument: ${year}`);
      }
      this.year = year;
      this.setMonth(month); // will throw if we can't parse
      day = parseInt(day, 10);
      if (isNaN(day)) {
        throw new TypeError(`HDate called with bad day argument: ${day}`);
      }
      this.setDate(day);
    } else {
      // 0 arguments
      if (typeof day === 'undefined') {
        day = new Date();
      }
      // 1 argument
      const abs0 = typeof day === 'number' && !isNaN(day) ? day : isDate(day) ? greg2abs(day) : HDate.isHDate(day) ? {
        dd: day.day,
        mm: day.month,
        yy: day.year
      } : throwTypeError(`HDate called with bad argument: ${day}`);
      const isNumber = typeof abs0 === 'number';
      const d = isNumber ? abs2hebrew(abs0) : abs0;
      /**
       * @private
       * @type {number}
       */
      this.day = d.dd;
      /**
       * @private
       * @type {number}
       */
      this.month = d.mm;
      /**
       * @private
       * @type {number}
       */
      this.year = d.yy;
      if (isNumber) {
        /**
         * @private
         * @type {number}
         */
        this.abs0 = abs0;
      }
    }
  }

  /**
   * Gets the Hebrew year of this Hebrew date
   * @return {number}
   */
  getFullYear() {
    return this.year;
  }

  /**
   * Tests if this date occurs during a leap year
   * @return {boolean}
   */
  isLeapYear() {
    return isLeapYear(this.year);
  }

  /**
   * Gets the Hebrew month (1=NISAN, 7=TISHREI) of this Hebrew date
   * @return {number}
   */
  getMonth() {
    return this.month;
  }

  /**
   * The Tishrei-based month of the date. 1 is Tishrei, 7 is Nisan, 13 is Elul in a leap year
   * @return {number}
   */
  getTishreiMonth() {
    const nummonths = monthsInYear(this.getFullYear());
    return (this.getMonth() + nummonths - 6) % nummonths || nummonths;
  }

  /**
   * Number of days in the month of this Hebrew date
   * @return {number}
   */
  daysInMonth() {
    return daysInMonth(this.getMonth(), this.getFullYear());
  }

  /**
   * Gets the day within the month (1-30)
   * @return {number}
   */
  getDate() {
    return this.day;
  }

  /**
   * Gets the day of the week. 0=Sunday, 6=Saturday
   * @return {number}
   */
  getDay() {
    return mod(this.abs(), 7);
  }

  /**
   * Sets the year of the date. Returns the object it was called upon.
   * @private
   * @deprecated
   * @param {number} year
   * @return {HDate}
   */
  setFullYear(year) {
    this.year = year;
    fix(this);
    return this;
  }

  /**
   * Sets the day of the month of the date. Returns the object it was called upon
   * @private
   * @param {number} month
   * @return {HDate}
   */
  setMonth(month) {
    this.month = HDate.monthNum(month);
    fix(this);
    return this;
  }

  /**
   * @private
   * @param {number} date
   * @return {HDate}
   */
  setDate(date) {
    this.day = date;
    fix(this);
    return this;
  }

  /**
   * Converts to Gregorian date
   * @return {Date}
   */
  greg() {
    return abs2greg(this.abs());
  }

  /**
   * Returns R.D. (Rata Die) fixed days.
   * R.D. 1 == Monday, January 1, 1 (Gregorian)
   * Note also that R.D. = Julian Date − 1,721,424.5
   * https://en.wikipedia.org/wiki/Rata_Die#Dershowitz_and_Reingold
   * @return {number}
   */
  abs() {
    if (typeof this.abs0 !== 'number') {
      this.abs0 = hebrew2abs(this.year, this.month, this.day);
    }
    return this.abs0;
  }

  /**
   * Converts Hebrew date to R.D. (Rata Die) fixed days.
   * R.D. 1 is the imaginary date Monday, January 1, 1 on the Gregorian
   * Calendar.
   * @param {number} year Hebrew year
   * @param {number} month Hebrew month
   * @param {number} day Hebrew date (1-30)
   * @return {number}
   */
  static hebrew2abs(year, month, day) {
    return hebrew2abs(year, month, day);
  }

  /**
   * Converts absolute R.D. days to Hebrew date
   * @private
   * @param {number} abs absolute R.D. days
   * @return {SimpleHebrewDate}
   */
  static abs2hebrew(abs) {
    return abs2hebrew(abs);
  }

  /**
   * Returns a transliterated Hebrew month name, e.g. `'Elul'` or `'Cheshvan'`.
   * @return {string}
   */
  getMonthName() {
    return getMonthName(this.getMonth(), this.getFullYear());
  }

  /**
   * Renders this Hebrew date as a translated or transliterated string,
   * including ordinal e.g. `'15th of Cheshvan, 5769'`.
   * @example
   * import {HDate, months} from '@hebcal/core';
   *
   * const hd = new HDate(15, months.CHESHVAN, 5769);
   * console.log(hd.render('en')); // '15th of Cheshvan, 5769'
   * console.log(hd.render('he')); // '15 חֶשְׁוָן, 5769'
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @param {boolean} [showYear=true] Display year (defaults to true).
   * @return {string}
   */
  render(locale = null, showYear = true) {
    const locale0 = locale || Locale.getLocaleName();
    const day = this.getDate();
    const monthName = Locale.gettext(this.getMonthName(), locale0);
    const nth = Locale.ordinal(day, locale0);
    const dayOf = HDate.getDayOfTranslation(locale0);
    const dateStr = `${nth}${dayOf} ${monthName}`;
    if (showYear) {
      const fullYear = this.getFullYear();
      return `${dateStr}, ${fullYear}`;
    } else {
      return dateStr;
    }
  }

  /**
   * @private
   * @param {string} locale
   * @return {string}
   */
  static getDayOfTranslation(locale) {
    switch (locale) {
      case 'en':
      case 's':
      case 'a':
      case 'ashkenazi':
        return ' of';
    }
    const ofStr = Locale.lookupTranslation('of', locale);
    if (ofStr) {
      return ' ' + ofStr;
    }
    if ('ashkenazi' === locale.substring(0, 9)) {
      return ' of';
    }
    return '';
  }

  /**
   * Renders this Hebrew date in Hebrew gematriya, regardless of locale.
   * @example
   * import {HDate, months} from '@hebcal/core';
   * const hd = new HDate(15, months.CHESHVAN, 5769);
   * console.log(hd.renderGematriya()); // 'ט״ו חֶשְׁוָן תשס״ט'
   * @param {boolean} [suppressNikud]
   * @return {string}
   */
  renderGematriya(suppressNikud = false) {
    const d = this.getDate();
    const locale = suppressNikud ? 'he-x-NoNikud' : 'he';
    const m = Locale.gettext(this.getMonthName(), locale);
    const y = this.getFullYear();
    return gematriya(d) + ' ' + m + ' ' + gematriya(y);
  }

  /**
   * Returns an `HDate` representing the a dayNumber before the current date.
   * Sunday=0, Saturday=6
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).before(6).greg() // Sat Feb 15 2014
   * @param {number} day day of week
   * @return {HDate}
   */
  before(day) {
    return onOrBefore(day, this, -1);
  }

  /**
   * Returns an `HDate` representing the a dayNumber on or before the current date.
   * Sunday=0, Saturday=6
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).onOrBefore(6).greg() // Sat Feb 15 2014
   * new HDate(new Date('Saturday February 22, 2014')).onOrBefore(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Sunday February 23, 2014')).onOrBefore(6).greg() // Sat Feb 22 2014
   * @param {number} dow day of week
   * @return {HDate}
   */
  onOrBefore(dow) {
    return onOrBefore(dow, this, 0);
  }

  /**
   * Returns an `HDate` representing the nearest dayNumber to the current date
   * Sunday=0, Saturday=6
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).nearest(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Tuesday February 18, 2014')).nearest(6).greg() // Sat Feb 15 2014
   * @param {number} dow day of week
   * @return {HDate}
   */
  nearest(dow) {
    return onOrBefore(dow, this, 3);
  }

  /**
   * Returns an `HDate` representing the a dayNumber on or after the current date.
   * Sunday=0, Saturday=6
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).onOrAfter(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Saturday February 22, 2014')).onOrAfter(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Sunday February 23, 2014')).onOrAfter(6).greg() // Sat Mar 01 2014
   * @param {number} dow day of week
   * @return {HDate}
   */
  onOrAfter(dow) {
    return onOrBefore(dow, this, 6);
  }

  /**
   * Returns an `HDate` representing the a dayNumber after the current date.
   * Sunday=0, Saturday=6
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).after(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Saturday February 22, 2014')).after(6).greg() // Sat Mar 01 2014
   * new HDate(new Date('Sunday February 23, 2014')).after(6).greg() // Sat Mar 01 2014
   * @param {number} day day of week
   * @return {HDate}
   */
  after(day) {
    return onOrBefore(day, this, 7);
  }

  /**
   * Returns the next Hebrew date
   * @return {HDate}
   */
  next() {
    return new HDate(this.abs() + 1);
  }

  /**
   * Returns the previous Hebrew date
   * @return {HDate}
   */
  prev() {
    return new HDate(this.abs() - 1);
  }

  /**
   * Returns a cloned `HDate` object with a specified amount of time added
   *
   * Units are case insensitive, and support plural and short forms.
   * Note, short forms are case sensitive.
   *
   * | Unit | Shorthand | Description
   * | --- | --- | --- |
   * | `day` | `d` | days |
   * | `week` | `w` | weeks |
   * | `month` | `M` | months |
   * | `year` | `y` | years |
   * @param {number} number
   * @param {string} [units]
   * @return {HDate}
   */
  add(number, units = 'd') {
    number = parseInt(number, 10);
    if (!number) {
      return new HDate(this);
    }
    units = HDate.standardizeUnits(units);
    if (units === UNITS_DAY) {
      return new HDate(this.abs() + number);
    } else if (units === UNITS_WEEK) {
      return new HDate(this.abs() + 7 * number);
    } else if (units === UNITS_YEAR) {
      return new HDate(this.getDate(), this.getMonth(), this.getFullYear() + number);
    } else if (units === UNITS_MONTH) {
      let hd = new HDate(this);
      const sign = number > 0 ? 1 : -1;
      number = Math.abs(number);
      for (let i = 0; i < number; i++) {
        hd = new HDate(hd.abs() + sign * hd.daysInMonth());
      }
      return hd;
    }
  }

  /**
   * @private
   * @param {string} units
   * @return {string}
   */
  static standardizeUnits(units) {
    const full = UNITS_SINGLE[units] || String(units || '').toLowerCase().replace(/s$/, '');
    return UNITS_VALID[full] || throwTypeError(`Invalid units '${units}'`);
  }

  /**
   * Returns a cloned `HDate` object with a specified amount of time subracted
   *
   * Units are case insensitive, and support plural and short forms.
   * Note, short forms are case sensitive.
   *
   * | Unit | Shorthand | Description
   * | --- | --- | --- |
   * | `day` | `d` | days |
   * | `week` | `w` | weeks |
   * | `month` | `M` | months |
   * | `year` | `y` | years |
   * @example
   * import {HDate, months} from '@hebcal/core';
   *
   * const hd1 = new HDate(15, months.CHESHVAN, 5769);
   * const hd2 = hd1.add(1, 'weeks'); // 7 Kislev 5769
   * const hd3 = hd1.add(-3, 'M'); // 30 Av 5768
   * @param {number} number
   * @param {string} [units]
   * @return {HDate}
   */
  subtract(number, units = 'd') {
    return this.add(number * -1, units);
  }

  /**
   * Returns the difference in days between the two given HDates.
   *
   * The result is positive if `this` date is comes chronologically
   * after the `other` date, and negative
   * if the order of the two dates is reversed.
   *
   * The result is zero if the two dates are identical.
   * @example
   * import {HDate, months} from '@hebcal/core';
   *
   * const hd1 = new HDate(25, months.KISLEV, 5770);
   * const hd2 = new HDate(15, months.CHESHVAN, 5769);
   * const days = hd1.deltaDays(hd2); // 394
   * @param {HDate} other Hebrew date to compare
   * @return {number}
   */
  deltaDays(other) {
    if (!HDate.isHDate(other)) {
      throw new TypeError(`Bad argument: ${other}`);
    }
    return this.abs() - other.abs();
  }

  /**
   * Compares this date to another date, returning `true` if the dates match.
   * @param {HDate} other Hebrew date to compare
   * @return {boolean}
   */
  isSameDate(other) {
    if (HDate.isHDate(other)) {
      return this.year == other.year && this.month == other.month && this.day == other.day;
    }
    return false;
  }

  /** @return {string} */
  toString() {
    const day = this.getDate();
    const fullYear = this.getFullYear();
    const monthName = this.getMonthName();
    return `${day} ${monthName} ${fullYear}`;
  }

  /**
   * Returns true if Hebrew year is a leap year
   * @param {number} year Hebrew year
   * @return {boolean}
   */
  static isLeapYear(year) {
    return isLeapYear(year);
  }

  /**
   * Number of months in this Hebrew year (either 12 or 13 depending on leap year)
   * @param {number} year Hebrew year
   * @return {number}
   */
  static monthsInYear(year) {
    return monthsInYear(year);
  }

  /**
   * Number of days in Hebrew month in a given year (29 or 30)
   * @param {number} month Hebrew month (e.g. months.TISHREI)
   * @param {number} year Hebrew year
   * @return {number}
   */
  static daysInMonth(month, year) {
    return daysInMonth(month, year);
  }

  /**
   * Returns a transliterated string name of Hebrew month in year,
   * for example 'Elul' or 'Cheshvan'.
   * @param {number} month Hebrew month (e.g. months.TISHREI)
   * @param {number} year Hebrew year
   * @return {string}
   */
  static getMonthName(month, year) {
    return getMonthName(month, year);
  }

  /**
   * Returns the Hebrew month number (NISAN=1, TISHREI=7)
   * @param {number|string} month A number, or Hebrew month name string
   * @return {number}
   */
  static monthNum(month) {
    if (typeof month === 'number') {
      if (isNaN(month) || month > 14) {
        throw new RangeError(`Invalid month number: ${month}`);
      }
      return month;
    }
    return month.charCodeAt(0) >= 48 && month.charCodeAt(0) <= 57 ? /* number */
    parseInt(month, 10) : HDate.monthFromName(month);
  }

  /**
   * Number of days in the hebrew YEAR
   * @param {number} year Hebrew year
   * @return {number}
   */
  static daysInYear(year) {
    return daysInYear(year);
  }

  /**
   * true if Cheshvan is long in Hebrew year
   * @param {number} year Hebrew year
   * @return {boolean}
   */
  static longCheshvan(year) {
    return longCheshvan(year);
  }

  /**
   * true if Kislev is short in Hebrew year
   * @param {number} year Hebrew year
   * @return {boolean}
   */
  static shortKislev(year) {
    return shortKislev(year);
  }

  /**
   * Converts Hebrew month string name to numeric
   * @param {string} monthName monthName
   * @return {number}
   */
  static monthFromName(monthName) {
    if (typeof monthName === 'number') {
      if (isNaN(monthName) || monthName < 1 || monthName > 14) {
        throw new RangeError(`Invalid month name: ${monthName}`);
      }
      return monthName;
    }
    const c = monthName.toLowerCase();
    /*
    the Hebrew months are unique to their second letter
    N         Nisan  (November?)
    I         Iyyar
    E        Elul
    C        Cheshvan
    K        Kislev
    1        1Adar
    2        2Adar
    Si Sh     Sivan, Shvat
    Ta Ti Te Tamuz, Tishrei, Tevet
    Av Ad    Av, Adar
     אב אד אי אל   אב אדר אייר אלול
    ח            חשון
    ט            טבת
    כ            כסלו
    נ            ניסן
    ס            סיון
    ש            שבט
    תמ תש        תמוז תשרי
    */
    switch (c[0]) {
      case 'n':
      case 'נ':
        if (c[1] == 'o') {
          break; /* this catches "november" */
        }

        return months.NISAN;
      case 'i':
        return months.IYYAR;
      case 'e':
        return months.ELUL;
      case 'c':
      case 'ח':
        return months.CHESHVAN;
      case 'k':
      case 'כ':
        return months.KISLEV;
      case 's':
        switch (c[1]) {
          case 'i':
            return months.SIVAN;
          case 'h':
            return months.SHVAT;
        }
      case 't':
        switch (c[1]) {
          case 'a':
            return months.TAMUZ;
          case 'i':
            return months.TISHREI;
          case 'e':
            return months.TEVET;
        }
        break;
      case 'a':
        switch (c[1]) {
          case 'v':
            return months.AV;
          case 'd':
            if (/(1|[^i]i|a|א)$/i.test(monthName)) {
              return months.ADAR_I;
            }
            return months.ADAR_II;
          // else assume sheini
        }

        break;
      case 'ס':
        return months.SIVAN;
      case 'ט':
        return months.TEVET;
      case 'ש':
        return months.SHVAT;
      case 'א':
        switch (c[1]) {
          case 'ב':
            return months.AV;
          case 'ד':
            if (/(1|[^i]i|a|א)$/i.test(monthName)) {
              return months.ADAR_I;
            }
            return months.ADAR_II;
          // else assume sheini
          case 'י':
            return months.IYYAR;
          case 'ל':
            return months.ELUL;
        }
        break;
      case 'ת':
        switch (c[1]) {
          case 'מ':
            return months.TAMUZ;
          case 'ש':
            return months.TISHREI;
        }
        break;
    }
    throw new RangeError(`Unable to parse month name: ${monthName}`);
  }

  /**
   * Note: Applying this function to d+6 gives us the DAYNAME on or after an
   * absolute day d. Similarly, applying it to d+3 gives the DAYNAME nearest to
   * absolute date d, applying it to d-1 gives the DAYNAME previous to absolute
   * date d, and applying it to d+7 gives the DAYNAME following absolute date d.
   * @param {number} dayOfWeek
   * @param {number} absdate
   * @return {number}
   */
  static dayOnOrBefore(dayOfWeek, absdate) {
    return absdate - (absdate - dayOfWeek) % 7;
  }

  /**
   * Tests if the object is an instance of `HDate`
   * @param {any} obj
   * @return {boolean}
   */
  static isHDate(obj) {
    return obj !== null && typeof obj === 'object' && typeof obj.year === 'number' && typeof obj.month === 'number' && typeof obj.day === 'number' && typeof obj.greg === 'function' && typeof obj.abs === 'function';
  }
}

/**
 * @private
 * @param {HDate} date
 */
function fix(date) {
  fixMonth(date);
  fixDate(date);
}

/**
 * @private
 * @param {HDate} date
 */
function fixDate(date) {
  if (date.day < 1) {
    if (date.month == months.TISHREI) {
      date.year -= 1;
    }
    date.day += daysInMonth(date.month, date.year);
    date.month -= 1;
    fix(date);
  }
  if (date.day > daysInMonth(date.month, date.year)) {
    if (date.month === months.ELUL) {
      date.year += 1;
    }
    date.day -= daysInMonth(date.month, date.year);
    date.month += 1;
    fix(date);
  }
  fixMonth(date);
}

/**
 * @private
 * @param {HDate} date
 */
function fixMonth(date) {
  if (date.month === months.ADAR_II && !date.isLeapYear()) {
    date.month -= 1; // to Adar I
    fix(date);
  } else if (date.month < 1) {
    date.month += monthsInYear(date.year);
    date.year -= 1;
    fix(date);
  } else if (date.month > monthsInYear(date.year)) {
    date.month -= monthsInYear(date.year);
    date.year += 1;
    fix(date);
  }
  delete date.abs0;
}

/**
 * @private
 * @param {number} day
 * @param {HDate} t
 * @param {number} offset
 * @return {HDate}
 */
function onOrBefore(day, t, offset) {
  return new HDate(HDate.dayOnOrBefore(day, t.abs() + offset));
}

/**
 * Holiday flags for Event
 * @readonly
 * @enum {number}
 */
const flags = {
  /** Chag, yontiff, yom tov */
  CHAG: 0x000001,
  /** Light candles 18 minutes before sundown */
  LIGHT_CANDLES: 0x000002,
  /** End of holiday (end of Yom Tov)  */
  YOM_TOV_ENDS: 0x000004,
  /** Observed only in the Diaspora (chutz l'aretz)  */
  CHUL_ONLY: 0x000008,
  /** Observed only in Israel */
  IL_ONLY: 0x000010,
  /** Light candles in the evening at Tzeit time (3 small stars) */
  LIGHT_CANDLES_TZEIS: 0x000020,
  /** Candle-lighting for Chanukah */
  CHANUKAH_CANDLES: 0x000040,
  /** Rosh Chodesh, beginning of a new Hebrew month */
  ROSH_CHODESH: 0x000080,
  /** Minor fasts like Tzom Tammuz, Ta'anit Esther, ... */
  MINOR_FAST: 0x000100,
  /** Shabbat Shekalim, Zachor, ... */
  SPECIAL_SHABBAT: 0x000200,
  /** Weekly sedrot on Saturdays */
  PARSHA_HASHAVUA: 0x000400,
  /** Daily page of Talmud (Bavli) */
  DAF_YOMI: 0x000800,
  /** Days of the Omer */
  OMER_COUNT: 0x001000,
  /** Yom HaShoah, Yom HaAtzma'ut, ... */
  MODERN_HOLIDAY: 0x002000,
  /** Yom Kippur and Tish'a B'Av */
  MAJOR_FAST: 0x004000,
  /** On the Saturday before Rosh Chodesh */
  SHABBAT_MEVARCHIM: 0x008000,
  /** Molad */
  MOLAD: 0x010000,
  /** Yahrzeit or Hebrew Anniversary */
  USER_EVENT: 0x020000,
  /** Daily Hebrew date ("11th of Sivan, 5780") */
  HEBREW_DATE: 0x040000,
  /** A holiday that's not major, modern, rosh chodesh, or a fast day */
  MINOR_HOLIDAY: 0x080000,
  /** Evening before a major or minor holiday */
  EREV: 0x100000,
  /** Chol haMoed, intermediate days of Pesach or Sukkot */
  CHOL_HAMOED: 0x200000,
  /** Mishna Yomi */
  MISHNA_YOMI: 0x400000,
  /** Yom Kippur Katan, minor day of atonement on the day preceeding each Rosh Chodesh */
  YOM_KIPPUR_KATAN: 0x800000,
  /** Daily page of Jerusalem Talmud (Yerushalmi) */
  YERUSHALMI_YOMI: 0x1000000,
  /** Nach Yomi */
  NACH_YOMI: 0x2000000
};
const flagToCategory = [[flags.MAJOR_FAST, 'holiday', 'major', 'fast'], [flags.CHANUKAH_CANDLES, 'holiday', 'major'], [flags.HEBREW_DATE, 'hebdate'], [flags.MINOR_FAST, 'holiday', 'fast'], [flags.MINOR_HOLIDAY, 'holiday', 'minor'], [flags.MODERN_HOLIDAY, 'holiday', 'modern'], [flags.MOLAD, 'molad'], [flags.OMER_COUNT, 'omer'], [flags.PARSHA_HASHAVUA, 'parashat'],
// backwards-compat
[flags.ROSH_CHODESH, 'roshchodesh'], [flags.SHABBAT_MEVARCHIM, 'mevarchim'], [flags.SPECIAL_SHABBAT, 'holiday', 'shabbat'], [flags.USER_EVENT, 'user']];

/** Represents an Event with a title, date, and flags */
class Event {
  /**
   * Constructs Event
   * @param {HDate} date Hebrew date event occurs
   * @param {string} desc Description (not translated)
   * @param {number} [mask=0] optional bitmask of holiday flags (see {@link flags})
   * @param {Object} [attrs={}] optional additional attributes (e.g. `eventTimeStr`, `cholHaMoedDay`)
   */
  constructor(date, desc, mask, attrs) {
    this.date = date;
    this.desc = desc;
    this.mask = +mask;
    if (typeof attrs === 'object' && attrs !== null) {
      Object.keys(attrs).forEach(k => this[k] = attrs[k]);
    }
  }
  /**
   * Hebrew date of this event
   * @return {HDate}
   */
  getDate() {
    return this.date;
  }
  /**
   * Untranslated description of this event
   * @return {string}
   */
  getDesc() {
    return this.desc;
  }
  /**
   * Bitmask of optional event flags. See {@link flags}
   * @return {number}
   */
  getFlags() {
    return this.mask;
  }
  /**
   * Returns (translated) description of this event
   * @example
   * const ev = new Event(new HDate(6, 'Sivan', 5749), 'Shavuot', flags.CHAG);
   * ev.render('en'); // 'Shavuot'
   * ev.render('he'); // 'שָׁבוּעוֹת'
   * ev.render('ashkenazi'); // 'Shavuos'
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    return Locale.gettext(this.desc, locale);
  }
  /**
   * Returns a brief (translated) description of this event.
   * For most events, this is the same as render(). For some events, it procudes
   * a shorter text (e.g. without a time or added description).
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  renderBrief(locale) {
    return this.render(locale);
  }
  /**
   * Optional holiday-specific Emoji or `null`.
   * @return {string}
   */
  getEmoji() {
    return this.emoji || null;
  }
  /**
   * Returns a simplified (untranslated) description for this event. For example,
   * the {@link HolidayEvent} class supports
   * "Erev Pesach" => "Pesach", and "Sukkot III (CH''M)" => "Sukkot".
   * For many holidays the basename and the event description are the same.
   * @return {string}
   */
  basename() {
    return this.getDesc();
  }
  /**
   * Returns a URL to hebcal.com or sefaria.org for more detail on the event.
   * Returns `undefined` for events with no detail page.
   * @return {string}
   */
  url() {
    return undefined;
  }
  /**
   * Is this event observed in Israel?
   * @example
   * const ev1 = new Event(new HDate(7, 'Sivan', 5749), 'Shavuot II', flags.CHAG | flags.CHUL_ONLY);
   * ev1.observedInIsrael(); // false
   * const ev2 = new Event(new HDate(26, 'Kislev', 5749), 'Chanukah: 3 Candles', 0);
   * ev2.observedInIsrael(); // true
   * @return {boolean}
   */
  observedInIsrael() {
    return !(this.mask & flags.CHUL_ONLY);
  }
  /**
   * Is this event observed in the Diaspora?
   * @example
   * const ev1 = new Event(new HDate(7, 'Sivan', 5749), 'Shavuot II', flags.CHAG | flags.CHUL_ONLY);
   * ev1.observedInDiaspora(); // true
   * const ev2 = new Event(new HDate(26, 'Kislev', 5749), 'Chanukah: 3 Candles', 0);
   * ev2.observedInDiaspora(); // true
   * @return {boolean}
   */
  observedInDiaspora() {
    return !(this.mask & flags.IL_ONLY);
  }
  /**
   * Is this event observed in Israel/Diaspora?
   * @example
   * const ev1 = new Event(new HDate(7, 'Sivan', 5749), 'Shavuot II', flags.CHAG | flags.CHUL_ONLY);
   * ev1.observedIn(false); // true
   * ev1.observedIn(true); // false
   * const ev2 = new Event(new HDate(26, 'Kislev', 5749), 'Chanukah: 3 Candles', 0);
   * ev2.observedIn(false); // true
   * ev2.observedIn(true); // true
   * @param {boolean} il
   * @return {boolean}
   */
  observedIn(il) {
    return il ? this.observedInIsrael() : this.observedInDiaspora();
  }
  /**
   * @deprecated
   * Optional additional event attributes (e.g. `eventTimeStr`, `cholHaMoedDay`)
   * @return {Object}
   */
  getAttrs() {
    return this;
  }
  /**
   * Makes a clone of this Event object
   * @return {Event}
   */
  clone() {
    const ev = new this.constructor();
    for (const property in this) {
      if (this.hasOwnProperty(property)) {
        ev[property] = this[property];
      }
    }
    return ev;
  }
  /**
   * Returns a list of event categories
   * @return {string[]}
   */
  getCategories() {
    const mask = this.getFlags();
    for (let i = 0; i < flagToCategory.length; i++) {
      const attrs = flagToCategory[i];
      if (mask & attrs[0]) {
        return attrs.slice(1);
      }
    }
    return ['unknown'];
  }
}

/** Daily Hebrew date ("11th of Sivan, 5780") */
class HebrewDateEvent extends Event {
  /**
   * @param {HDate} date
   */
  constructor(date) {
    super(date, date.toString(), flags.HEBREW_DATE);
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @example
   * import {HDate, HebrewDateEvent, months} from '@hebcal/core';
   *
   * const hd = new HDate(15, months.CHESHVAN, 5769);
   * const ev = new HebrewDateEvent(hd);
   * console.log(ev.render('en')); // '15th of Cheshvan, 5769'
   * console.log(ev.render('he')); // 'ט״ו חֶשְׁוָן תשס״ט'
   * @return {string}
   */
  render(locale) {
    const locale1 = locale && locale.toLowerCase();
    const locale0 = locale1 || Locale.getLocaleName();
    const hd = this.getDate();
    switch (locale0) {
      case 'h':
      case 'he':
      case 'he-x-nonikud':
        const dd = hd.getDate();
        const mm = Locale.gettext(hd.getMonthName(), locale0);
        const yy = hd.getFullYear();
        return gematriya(dd) + ' ' + mm + ' ' + gematriya(yy);
      default:
        return hd.render(locale0, true);
    }
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @example
   * import {HDate, HebrewDateEvent, months} from '@hebcal/core';
   *
   * const hd = new HDate(15, months.CHESHVAN, 5769);
   * const ev = new HebrewDateEvent(hd);
   * console.log(ev.renderBrief()); // '15th of Cheshvan'
   * console.log(ev.renderBrief('he')); // 'ט״ו חֶשְׁוָן'
   * @return {string}
   */
  renderBrief(locale) {
    const locale1 = locale && locale.toLowerCase();
    const locale0 = locale1 || Locale.getLocaleName();
    const hd = this.getDate();
    if (hd.getMonth() === months.TISHREI && hd.getDate() === 1) {
      return this.render(locale0);
    }
    switch (locale0) {
      case 'h':
      case 'he':
      case 'he-x-nonikud':
        const dd = hd.getDate();
        const mm = Locale.gettext(hd.getMonthName(), locale0);
        return gematriya(dd) + ' ' + mm;
      default:
        return hd.render(locale0, false);
    }
  }
  /**
   * Helper function to render a Hebrew date
   * @deprecated
   * @param {number} day
   * @param {string} monthName
   * @param {number} fullYear
   * @return {string}
   */
  static renderHebrew(day, monthName, fullYear) {
    return gematriya(day) + ' ' + monthName + ' ' + gematriya(fullYear);
  }
}

class Sun {
  constructor(date, latitude, longitude) {
    this.date = date;
    this.latitude = latitude;
    this.longitude = longitude;

    this.julianDate = getJD(date);
  }

  get solarNoon() {
    return calcSolNoon(this.julianDate, this.longitude, this.date);
  }

  timeAtAngle(angle, rising) {
    return calcSunriseSet(rising, angle, this.julianDate, this.date, this.latitude, this.longitude);
  }
}

function formatDate(date, minutes) {
  const seconds = (minutes - Math.floor(minutes)) * 60;
  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, minutes, seconds));
}

function calcTimeJulianCent(jd) {
  const T = (jd - 2451545.0) / 36525.0;
  return T;
}

function radToDeg(angleRad) {
  return (180.0 * angleRad / Math.PI);
}

function degToRad(angleDeg) {
  return (Math.PI * angleDeg / 180.0);
}

function calcGeomMeanLongSun(t) {
  let L0 = 280.46646 + t * (36000.76983 + t * (0.0003032));
  while (L0 > 360.0) {
    L0 -= 360.0;
  }
  while (L0 < 0.0) {
    L0 += 360.0;
  }
  return L0; // in degrees
}

function calcGeomMeanAnomalySun(t) {
  const M = 357.52911 + t * (35999.05029 - 0.0001537 * t);
  return M; // in degrees
}

function calcEccentricityEarthOrbit(t) {
  const e = 0.016708634 - t * (0.000042037 + 0.0000001267 * t);
  return e; // unitless
}

function calcSunEqOfCenter(t) {
  const m = calcGeomMeanAnomalySun(t);
  const mrad = degToRad(m);
  const sinm = Math.sin(mrad);
  const sin2m = Math.sin(mrad + mrad);
  const sin3m = Math.sin(mrad + mrad + mrad);
  const C = sinm * (1.914602 - t * (0.004817 + 0.000014 * t)) + sin2m * (0.019993 - 0.000101 * t) + sin3m * 0.000289;
  return C; // in degrees
}

function calcSunTrueLong(t) {
  const l0 = calcGeomMeanLongSun(t);
  const c = calcSunEqOfCenter(t);
  const O = l0 + c;
  return O; // in degrees
}

function calcSunApparentLong(t) {
  const o = calcSunTrueLong(t);
  const omega = 125.04 - 1934.136 * t;
  const lambda = o - 0.00569 - 0.00478 * Math.sin(degToRad(omega));
  return lambda; // in degrees
}

function calcMeanObliquityOfEcliptic(t) {
  const seconds = 21.448 - t * (46.8150 + t * (0.00059 - t * (0.001813)));
  const e0 = 23.0 + (26.0 + (seconds / 60.0)) / 60.0;
  return e0; // in degrees
}

function calcObliquityCorrection(t) {
  const e0 = calcMeanObliquityOfEcliptic(t);
  const omega = 125.04 - 1934.136 * t;
  const e = e0 + 0.00256 * Math.cos(degToRad(omega));
  return e; // in degrees
}

function calcSunDeclination(t) {
  const e = calcObliquityCorrection(t);
  const lambda = calcSunApparentLong(t);

  const sint = Math.sin(degToRad(e)) * Math.sin(degToRad(lambda));
  const theta = radToDeg(Math.asin(sint));
  return theta; // in degrees
}

function calcEquationOfTime(t) {
  const epsilon = calcObliquityCorrection(t);
  const l0 = calcGeomMeanLongSun(t);
  const e = calcEccentricityEarthOrbit(t);
  const m = calcGeomMeanAnomalySun(t);

  let y = Math.tan(degToRad(epsilon) / 2.0);
  y *= y;

  const sin2l0 = Math.sin(2.0 * degToRad(l0));
  const sinm = Math.sin(degToRad(m));
  const cos2l0 = Math.cos(2.0 * degToRad(l0));
  const sin4l0 = Math.sin(4.0 * degToRad(l0));
  const sin2m = Math.sin(2.0 * degToRad(m));

  const Etime = y * sin2l0 - 2.0 * e * sinm + 4.0 * e * y * sinm * cos2l0 - 0.5 * y * y * sin4l0 - 1.25 * e * e * sin2m;
  return radToDeg(Etime) * 4.0; // in minutes of time
}

function calcHourAngle(angle, lat, solarDec) {
  const latRad = degToRad(lat);
  const sdRad = degToRad(solarDec);
  const HAarg = (Math.cos(degToRad(90 + angle)) / (Math.cos(latRad) * Math.cos(sdRad)) - Math.tan(latRad) * Math.tan(sdRad));
  const HA = Math.acos(HAarg);
  return HA; // in radians (for sunset, use -HA)
}

function isNumber(inputVal) {
  let oneDecimal = false;
  const inputStr = `${inputVal}`;
  for (let i = 0; i < inputStr.length; i++) {
    const oneChar = inputStr.charAt(i);
    if (i === 0 && (oneChar === '-' || oneChar === '+')) {
      continue;
    }
    if (oneChar === '.' && !oneDecimal) {
      oneDecimal = true;
      continue;
    }
    if (oneChar < '0' || oneChar > '9') {
      return false;
    }
  }
  return true;
}

function getJD(date) {
  let year = date.getFullYear();
  let month = date.getMonth() + 1;
  const day = date.getDate();
  if (month < 3) {
    year--;
    month += 12;
  }

  const A = Math.floor(year / 100);
  const B = 2 - A + Math.floor(A / 4);
  const JD = Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + B - 1524.5;
  return JD;
}

function calcSolNoon(jd, longitude, date) {
  const tnoon = calcTimeJulianCent(jd - longitude / 360.0);
  let eqTime = calcEquationOfTime(tnoon);
  const solNoonOffset = 720.0 - (longitude * 4) - eqTime; // in minutes
  const newt = calcTimeJulianCent(jd + solNoonOffset / 1440.0);
  eqTime = calcEquationOfTime(newt);
  let solNoonLocal = 720 - (longitude * 4) - eqTime; // in minutes
  while (solNoonLocal < 0.0) {
    solNoonLocal += 1440.0;
  }
  while (solNoonLocal >= 1440.0) {
    solNoonLocal -= 1440.0;
  }
  return formatDate(date, solNoonLocal);
  // return timeString(solNoonLocal, 3);
}

function calcSunriseSetUTC(rise, angle, JD, latitude, longitude) {
  const t = calcTimeJulianCent(JD);
  const eqTime = calcEquationOfTime(t);
  const solarDec = calcSunDeclination(t);
  let hourAngle = calcHourAngle(angle, latitude, solarDec);
  //alert("HA = " + radToDeg(hourAngle));
  if (!rise) hourAngle = -hourAngle;
  const delta = longitude + radToDeg(hourAngle);
  const timeUTC = 720 - (4.0 * delta) - eqTime; // in minutes
  return timeUTC;
}

function calcSunriseSet(rise, angle, JD, date, latitude, longitude)
  // rise = 1 for sunrise, 0 for sunset
  {
    const timeUTC = calcSunriseSetUTC(rise, angle, JD, latitude, longitude);
    const newTimeUTC = calcSunriseSetUTC(rise, angle, JD + timeUTC / 1440.0, latitude, longitude);
    if (isNumber(newTimeUTC)) {

      return formatDate(date, newTimeUTC);

    } else { // no sunrise/set found
      return new Date(NaN);
    }
  }

const degreesBelowHorizon = {
  sunrise: 0.833,
  sunriseEnd: 0.3,
  twilight: 6,
  nauticalTwilight: 12,
  night: 18,
  goldenHour: -6
};

class SolarCalc {
  constructor(date, latitude, longitude) {
    this.date = date;
    this.lat = latitude;
    this.longitude = longitude;

    this.sun = new Sun(date, latitude, longitude);
  }

  get solarNoon() {
    return this.sun.solarNoon;
  }

  get sunrise() {
    return this.sun.timeAtAngle(degreesBelowHorizon.sunrise, true);
  }

  get sunset() {
    return this.sun.timeAtAngle(degreesBelowHorizon.sunrise);
  }

  get sunriseEnd() {
    return this.sun.timeAtAngle(degreesBelowHorizon.sunriseEnd, true);
  }

  get sunsetStart() {
    return this.sun.timeAtAngle(degreesBelowHorizon.sunriseEnd, false);
  }

  get civilDawn() {
    return this.sun.timeAtAngle(degreesBelowHorizon.twilight, true);
  }

  get dawn() {
    return this.civilDawn;
  }

  get civilDusk() {
    return this.sun.timeAtAngle(degreesBelowHorizon.twilight, false);
  }

  get dusk() {
    return this.civilDusk;
  }

  get nauticalDawn() {
    return this.sun.timeAtAngle(degreesBelowHorizon.nauticalTwilight, true);
  }

  get nauticalDusk() {
    return this.sun.timeAtAngle(degreesBelowHorizon.nauticalTwilight, false);
  }

  get nightStart() {
    return this.astronomicalDusk;
  }

  get astronomicalDusk() {
    return this.sun.timeAtAngle(degreesBelowHorizon.night, false);
  }

  get astronomicalDawn() {
    return this.sun.timeAtAngle(degreesBelowHorizon.night, true);
  }

  get nightEnd() {
    return this.astronomicalDawn;
  }

  get goldenHourStart() {
    return this.sun.timeAtAngle(degreesBelowHorizon.goldenHour, false);
  }

  get goldenHourEnd() {
    return this.sun.timeAtAngle(degreesBelowHorizon.goldenHour, true);
  }
}

const _formatters = {};

/**
 * @private
 * @param {string} tzid
 * @return {Intl.DateTimeFormat}
 */
function getFormatter$1(tzid) {
  const fmt = _formatters[tzid];
  if (fmt) return fmt;
  const f = new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false,
    timeZone: tzid
  });
  _formatters[tzid] = f;
  return f;
}
const dateFormatRegex = /^(\d+).(\d+).(\d+),?\s+(\d+).(\d+).(\d+)/;

/**
 * @private
 * @param {string} tzid
 * @param {Date} date
 * @return {string}
 */
function getPseudoISO(tzid, date) {
  const str = getFormatter$1(tzid).format(date);
  const m = dateFormatRegex.exec(str);
  let hour = m[4];
  if (hour == '24') hour = '00';
  m[3] = pad4(m[3]);
  return `${m[3]}-${m[1]}-${m[2]}T${hour}:${m[5]}:${m[6]}Z`;
}

/**
 * @private
 * @param {string} tzid
 * @param {Date} date
 * @return {number}
 */
function getTimezoneOffset(tzid, date) {
  const utcStr = getPseudoISO('UTC', date);
  const localStr = getPseudoISO(tzid, date);
  const diffMs = new Date(utcStr).getTime() - new Date(localStr).getTime();
  return Math.ceil(diffMs / 1000 / 60);
}

/**
 * @private
 * @param {number} number
 * @return {string}
 */
function pad4(number) {
  if (number < 0) {
    return '-00' + pad4(-number);
  } else if (number < 10) {
    return '000' + number;
  } else if (number < 100) {
    return '00' + number;
  } else if (number < 1000) {
    return '0' + number;
  }
  return String(number);
}

/**
 * @private
 * @param {number} number
 * @return {string}
 */
function pad2(number) {
  if (number < 10) {
    return '0' + number;
  }
  return String(number);
}

/**
 * @typedef {Object} ZmanimTimesResult
 * @property {Date} dawn
 * @property {Date} dusk
 * @property {Date} goldenHour
 * @property {Date} goldenHourEnd
 * @property {Date} nauticalDawn
 * @property {Date} nauticalDusk
 * @property {Date} night
 * @property {Date} nightEnd
 * @property {Date} solarNoon
 * @property {Date} sunrise
 * @property {Date} sunriseEnd
 * @property {Date} sunset
 * @property {Date} sunsetStart
 * @property {Date} alotHaShachar
 * @property {Date} misheyakir
 * @property {Date} misheyakirMachmir
 * @property {Date} tzeit
*/

/** Class representing halachic times */
class Zmanim {
  /**
     * Initialize a Zmanim instance.
     * @param {Date|HDate} date Regular or Hebrew Date. If `date` is a regular `Date`,
     *    hours, minutes, seconds and milliseconds are ignored.
     * @param {number} latitude
     * @param {number} longitude
     */
  constructor(date, latitude, longitude) {
    if (typeof latitude !== 'number') throw new TypeError('Invalid latitude');
    if (typeof longitude !== 'number') throw new TypeError('Invalid longitude');
    if (latitude < -90 || latitude > 90) {
      throw new RangeError(`Latitude ${latitude} out of range [-90,90]`);
    }
    if (longitude < -180 || longitude > 180) {
      throw new RangeError(`Longitude ${longitude} out of range [-180,180]`);
    }
    const dt = isDate(date) ? date : HDate.isHDate(date) ? date.greg() : throwTypeError(`invalid date: ${date}`);
    this.date = dt;
    this.solarCalc = new SolarCalc(this.date, latitude, longitude);
    this.sun = this.solarCalc.sun;
    this.latitude = latitude;
    this.longitude = longitude;
  }
  /**
   * @deprecated
   * @return {ZmanimTimesResult}
   */
  suntime() {
    return {
      solarNoon: this.solarCalc.solarNoon,
      sunrise: this.sunrise(),
      sunset: this.sunset(),
      sunriseEnd: this.solarCalc.sunriseEnd,
      sunsetStart: this.solarCalc.sunsetStart,
      dawn: this.dawn(),
      dusk: this.dusk(),
      nauticalDawn: this.solarCalc.nauticalDawn,
      nauticalDusk: this.solarCalc.nauticalDusk,
      nightEnd: this.solarCalc.nightEnd,
      night: this.solarCalc.nightStart,
      goldenHourEnd: this.solarCalc.goldenHourEnd,
      goldenHour: this.solarCalc.goldenHourStart,
      alotHaShachar: this.alotHaShachar(),
      misheyakir: this.misheyakir(),
      misheyakirMachmir: this.misheyakirMachmir(),
      tzeit: this.tzeit()
    };
  }
  /**
   * Upper edge of the Sun appears over the eastern horizon in the morning (0.833° above horizon)
   * @return {Date}
   */
  sunrise() {
    return this.sun.timeAtAngle(0.833333, true);
  }
  /**
   * When the upper edge of the Sun disappears below the horizon (0.833° below horizon)
   * @return {Date}
   */
  sunset() {
    return this.sun.timeAtAngle(0.833333, false);
  }
  /**
   * Civil dawn; Sun is 6° below the horizon in the morning
   * @return {Date}
   */
  dawn() {
    return this.solarCalc.dawn;
  }
  /**
   * Civil dusk; Sun is 6° below the horizon in the evening
   * @return {Date}
   */
  dusk() {
    return this.solarCalc.dusk;
  }
  /** @return {number} */
  hour() {
    return (this.sunset() - this.sunrise()) / 12; // ms in hour
  }
  /** @return {number} */
  hourMins() {
    // hour in ms / (1000 ms in s * 60 s in m) = mins in halachic hour
    return this.hour() / (1000 * 60);
  }
  /** @return {Date} */
  gregEve() {
    const prev = new Date(this.date);
    prev.setDate(prev.getDate() - 1);
    const zman = new Zmanim(prev, this.latitude, this.longitude);
    return zman.sunset();
  }
  /** @return {number} */
  nightHour() {
    return (this.sunrise() - this.gregEve()) / 12; // ms in hour
  }
  /** @return {number} */
  nightHourMins() {
    // hour in ms / (1000 ms in s * 60 s in m) = mins in halachic hour
    return this.nightHour() / (1000 * 60);
  }
  /**
     * @param {number} hours
     * @return {Date}
     */
  hourOffset(hours) {
    return new Date(this.sunrise().getTime() + this.hour() * hours);
  }
  /**
   * Midday – Chatzot; Sunrise plus 6 halachic hours
   * @return {Date}
   */
  chatzot() {
    return this.hourOffset(6);
  }
  /**
   * Midnight – Chatzot; Sunset plus 6 halachic hours
   * @return {Date}
   */
  chatzotNight() {
    return new Date(this.sunrise().getTime() - this.nightHour() * 6);
  }
  /**
   * Dawn – Alot haShachar; Sun is 16.1° below the horizon in the morning
   * @return {Date}
   */
  alotHaShachar() {
    return this.sun.timeAtAngle(16.1, true);
  }
  /**
   * Earliest talis & tefillin – Misheyakir; Sun is 11.5° below the horizon in the morning
   * @return {Date}
   */
  misheyakir() {
    return this.sun.timeAtAngle(11.5, true);
  }
  /**
   * Earliest talis & tefillin – Misheyakir Machmir; Sun is 10.2° below the horizon in the morning
   * @return {Date}
   */
  misheyakirMachmir() {
    return this.sun.timeAtAngle(10.2, true);
  }
  /**
   * Latest Shema (Gra); Sunrise plus 3 halachic hours, according to the Gra
   * @return {Date}
   */
  sofZmanShma() {
    // Gra
    return this.hourOffset(3);
  }
  /**
   * Latest Shacharit (Gra); Sunrise plus 4 halachic hours, according to the Gra
   * @return {Date}
   */
  sofZmanTfilla() {
    // Gra
    return this.hourOffset(4);
  }
  /**
   * Latest Shema (MGA); Sunrise plus 3 halachic hours, according to Magen Avraham
   * @return {Date}
   */
  sofZmanShmaMGA() {
    // Magen Avraham
    const alot72 = this.sunriseOffset(-72, false);
    const tzeit72 = this.sunsetOffset(72, false);
    const temporalHour = (tzeit72 - alot72) / 12; // ms in hour
    return new Date(alot72.getTime() + 3 * temporalHour);
  }
  /**
   * Latest Shacharit (MGA); Sunrise plus 4 halachic hours, according to Magen Avraham
   * @return {Date}
   */
  sofZmanTfillaMGA() {
    // Magen Avraham
    const alot72 = this.sunriseOffset(-72, false);
    const tzeit72 = this.sunsetOffset(72, false);
    const temporalHour = (tzeit72 - alot72) / 12; // ms in hour
    return new Date(alot72.getTime() + 4 * temporalHour);
  }
  /**
   * Earliest Mincha – Mincha Gedola; Sunrise plus 6.5 halachic hours
   * @return {Date}
   */
  minchaGedola() {
    return this.hourOffset(6.5);
  }
  /**
   * Preferable earliest time to recite Minchah – Mincha Ketana; Sunrise plus 9.5 halachic hours
   * @return {Date}
   */
  minchaKetana() {
    return this.hourOffset(9.5);
  }
  /**
   * Plag haMincha; Sunrise plus 10.75 halachic hours
   * @return {Date}
   */
  plagHaMincha() {
    return this.hourOffset(10.75);
  }
  /**
   * @param {number} [angle=8.5] optional time for solar depression.
   *   Default is 8.5 degrees for 3 small stars, use 7.083 degress for 3 medium-sized stars.
   * @return {Date}
   */
  tzeit(angle = 8.5) {
    return this.sun.timeAtAngle(angle, false);
  }
  /**
   * Alias for sunrise
   * @return {Date}
   */
  neitzHaChama() {
    return this.sunrise();
  }
  /**
   * Alias for sunset
   * @return {Date}
   */
  shkiah() {
    return this.sunset();
  }

  /**
   * Uses timeFormat to return a date like '20:34'
   * @param {Date} dt
   * @param {Intl.DateTimeFormat} timeFormat
   * @return {string}
   */
  static formatTime(dt, timeFormat) {
    const time = timeFormat.format(dt);
    const hm = time.split(':');
    if (hm[0] === '24') {
      return '00:' + hm[1];
    }
    return time;
  }

  /**
   * Discards seconds, rounding to nearest minute.
   * @param {Date} dt
   * @return {Date}
   */
  static roundTime(dt) {
    const millis = dt.getTime();
    if (isNaN(millis)) {
      return dt;
    }
    // Round up to next minute if needed
    const millisOnly = dt.getMilliseconds();
    const seconds = dt.getSeconds();
    if (seconds === 0 && millisOnly === 0) {
      return dt;
    }
    const secAndMillis = seconds * 1000 + millisOnly;
    const delta = secAndMillis >= 30000 ? 60000 - secAndMillis : -1 * secAndMillis;
    return new Date(millis + delta);
  }

  /**
   * Get offset string (like "+05:00" or "-08:00") from tzid (like "Europe/Moscow")
   * @param {string} tzid
   * @param {Date} date
   * @return {string}
   */
  static timeZoneOffset(tzid, date) {
    const offset = getTimezoneOffset(tzid, date);
    const offsetAbs = Math.abs(offset);
    const hours = Math.floor(offsetAbs / 60);
    const minutes = offsetAbs % 60;
    return (offset < 0 ? '+' : '-') + pad2(hours) + ':' + pad2(minutes);
  }

  /**
   * Returns a string like "2022-04-01T13:06:00-11:00"
   * @param {string} tzid
   * @param {Date} date
   * @return {string}
   */
  static formatISOWithTimeZone(tzid, date) {
    if (isNaN(date.getTime())) {
      return null;
    }
    return getPseudoISO(tzid, date).substring(0, 19) + Zmanim.timeZoneOffset(tzid, date);
  }

  /**
   * Returns sunrise + `offset` minutes (either positive or negative).
   * @param {number} offset minutes
   * @param {boolean} roundMinute round time to nearest minute (default true)
   * @return {Date}
   */
  sunriseOffset(offset, roundMinute = true) {
    const sunrise = this.sunrise();
    if (isNaN(sunrise.getTime())) {
      return sunrise;
    }
    if (roundMinute) {
      // For positive offsets only, round up to next minute if needed
      if (offset > 0 && sunrise.getSeconds() >= 30) {
        offset++;
      }
      sunrise.setSeconds(0, 0);
    }
    return new Date(sunrise.getTime() + offset * 60 * 1000);
  }

  /**
   * Returns sunset + `offset` minutes (either positive or negative).
   * @param {number} offset minutes
   * @param {boolean} roundMinute round time to nearest minute (default true)
   * @return {Date}
   */
  sunsetOffset(offset, roundMinute = true) {
    const sunset = this.sunset();
    if (isNaN(sunset.getTime())) {
      return sunset;
    }
    if (roundMinute) {
      // For Havdalah only, round up to next minute if needed
      if (offset > 0 && sunset.getSeconds() >= 30) {
        offset++;
      }
      sunset.setSeconds(0, 0);
    }
    return new Date(sunset.getTime() + offset * 60 * 1000);
  }

  /**
   * Returns an array with sunset + offset Date object, and a 24-hour string formatted time.
   * @deprecated
   * @param {number} offset
   * @param {Intl.DateTimeFormat} timeFormat
   * @return {Object[]}
   */
  sunsetOffsetTime(offset, timeFormat) {
    const dt = this.sunsetOffset(offset, true);
    if (isNaN(dt.getTime())) {
      // `No sunset for ${location} on ${hd}`
      return [undefined, undefined];
    }
    const time = Zmanim.formatTime(dt, timeFormat);
    return [dt, time];
  }

  /**
   * Returns an array with tzeit Date object and a 24-hour string formatted time.
   * @deprecated
   * @param {number} angle degrees for solar depression.
   *   Default is 8.5 degrees for 3 small stars, use 7.083 degress for 3 medium-sized stars.
   * @param {Intl.DateTimeFormat} timeFormat
   * @return {Object[]}
   */
  tzeitTime(angle, timeFormat) {
    const dt = this.tzeit(angle);
    if (isNaN(dt.getTime())) {
      return [undefined, undefined];
    }
    const time = Zmanim.roundTime(dt);
    const timeStr = Zmanim.formatTime(time, timeFormat);
    return [time, timeStr];
  }
}

/*
    Hebcal - A Jewish Calendar Generator
    Copyright (c) 1994-2020 Danny Sadinoff
    Portions copyright Eyal Schachter and Michael J. Radwin

    https://github.com/hebcal/hebcal-es6

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

const classicCities0 = [['Ashdod', 'IL', 31.79213, 34.64966, 'Asia/Jerusalem'], ['Atlanta', 'US', 33.749, -84.38798, 'America/New_York'], ['Austin', 'US', 30.26715, -97.74306, 'America/Chicago'], ['Baghdad', 'IQ', 33.34058, 44.40088, 'Asia/Baghdad'], ['Beer Sheva', 'IL', 31.25181, 34.7913, 'Asia/Jerusalem'], ['Berlin', 'DE', 52.52437, 13.41053, 'Europe/Berlin'], ['Baltimore', 'US', 39.29038, -76.61219, 'America/New_York'], ['Bogota', 'CO', 4.60971, -74.08175, 'America/Bogota'], ['Boston', 'US', 42.35843, -71.05977, 'America/New_York'], ['Budapest', 'HU', 47.49801, 19.03991, 'Europe/Budapest'], ['Buenos Aires', 'AR', -34.61315, -58.37723, 'America/Argentina/Buenos_Aires'], ['Buffalo', 'US', 42.88645, -78.87837, 'America/New_York'], ['Chicago', 'US', 41.85003, -87.65005, 'America/Chicago'], ['Cincinnati', 'US', 39.162, -84.45689, 'America/New_York'], ['Cleveland', 'US', 41.4995, -81.69541, 'America/New_York'], ['Dallas', 'US', 32.78306, -96.80667, 'America/Chicago'], ['Denver', 'US', 39.73915, -104.9847, 'America/Denver'], ['Detroit', 'US', 42.33143, -83.04575, 'America/Detroit'], ['Eilat', 'IL', 29.55805, 34.94821, 'Asia/Jerusalem'], ['Gibraltar', 'GI', 36.14474, -5.35257, 'Europe/Gibraltar'], ['Haifa', 'IL', 32.81841, 34.9885, 'Asia/Jerusalem'], ['Hawaii', 'US', 21.30694, -157.85833, 'Pacific/Honolulu'], ['Helsinki', 'FI', 60.16952, 24.93545, 'Europe/Helsinki'], ['Houston', 'US', 29.76328, -95.36327, 'America/Chicago'], ['Jerusalem', 'IL', 31.76904, 35.21633, 'Asia/Jerusalem'], ['Johannesburg', 'ZA', -26.20227, 28.04363, 'Africa/Johannesburg'], ['Kiev', 'UA', 50.45466, 30.5238, 'Europe/Kiev'], ['La Paz', 'BO', -16.5, -68.15, 'America/La_Paz'], ['Livingston', 'US', 40.79593, -74.31487, 'America/New_York'], ['Las Vegas', 'US', 36.17497, -115.13722, 'America/Los_Angeles'], ['London', 'GB', 51.50853, -0.12574, 'Europe/London'], ['Los Angeles', 'US', 34.05223, -118.24368, 'America/Los_Angeles'], ['Marseilles', 'FR', 43.29695, 5.38107, 'Europe/Paris'], ['Miami', 'US', 25.77427, -80.19366, 'America/New_York'], ['Minneapolis', 'US', 44.97997, -93.26384, 'America/Chicago'], ['Melbourne', 'AU', -37.814, 144.96332, 'Australia/Melbourne'], ['Mexico City', 'MX', 19.42847, -99.12766, 'America/Mexico_City'], ['Montreal', 'CA', 45.50884, -73.58781, 'America/Toronto'], ['Moscow', 'RU', 55.75222, 37.61556, 'Europe/Moscow'], ['New York', 'US', 40.71427, -74.00597, 'America/New_York'], ['Omaha', 'US', 41.25861, -95.93779, 'America/Chicago'], ['Ottawa', 'CA', 45.41117, -75.69812, 'America/Toronto'], ['Panama City', 'PA', 8.9936, -79.51973, 'America/Panama'], ['Paris', 'FR', 48.85341, 2.3488, 'Europe/Paris'], ['Pawtucket', 'US', 41.87871, -71.38256, 'America/New_York'], ['Petach Tikvah', 'IL', 32.08707, 34.88747, 'Asia/Jerusalem'], ['Philadelphia', 'US', 39.95233, -75.16379, 'America/New_York'], ['Phoenix', 'US', 33.44838, -112.07404, 'America/Phoenix'], ['Pittsburgh', 'US', 40.44062, -79.99589, 'America/New_York'], ['Providence', 'US', 41.82399, -71.41283, 'America/New_York'], ['Portland', 'US', 45.52345, -122.67621, 'America/Los_Angeles'], ['Saint Louis', 'US', 38.62727, -90.19789, 'America/Chicago'], ['Saint Petersburg', 'RU', 59.93863, 30.31413, 'Europe/Moscow'], ['San Diego', 'US', 32.71533, -117.15726, 'America/Los_Angeles'], ['San Francisco', 'US', 37.77493, -122.41942, 'America/Los_Angeles'], ['Sao Paulo', 'BR', -23.5475, -46.63611, 'America/Sao_Paulo'], ['Seattle', 'US', 47.60621, -122.33207, 'America/Los_Angeles'], ['Sydney', 'AU', -33.86785, 151.20732, 'Australia/Sydney'], ['Tel Aviv', 'IL', 32.08088, 34.78057, 'Asia/Jerusalem'], ['Tiberias', 'IL', 32.79221, 35.53124, 'Asia/Jerusalem'], ['Toronto', 'CA', 43.70011, -79.4163, 'America/Toronto'], ['Vancouver', 'CA', 49.24966, -123.11934, 'America/Vancouver'], ['White Plains', 'US', 41.03399, -73.76291, 'America/New_York'], ['Washington DC', 'US', 38.89511, -77.03637, 'America/New_York'], ['Worcester', 'US', 42.26259, -71.80229, 'America/New_York']];
const classicCities = Object.create(null);

// Zip-Codes.com TimeZone IDs
const ZIPCODES_TZ_MAP = {
  '0': 'UTC',
  '4': 'America/Puerto_Rico',
  // Atlantic (GMT -04:00)
  '5': 'America/New_York',
  //    Eastern  (GMT -05:00)
  '6': 'America/Chicago',
  //     Central  (GMT -06:00)
  '7': 'America/Denver',
  //      Mountain (GMT -07:00)
  '8': 'America/Los_Angeles',
  // Pacific  (GMT -08:00)
  '9': 'America/Anchorage',
  //   Alaska   (GMT -09:00)
  '10': 'Pacific/Honolulu',
  //   Hawaii-Aleutian Islands (GMT -10:00)
  '11': 'Pacific/Pago_Pago',
  //  American Samoa (GMT -11:00)
  '13': 'Pacific/Funafuti',
  //   Marshall Islands (GMT +12:00)
  '14': 'Pacific/Guam',
  //       Guam     (GMT +10:00)
  '15': 'Pacific/Palau',
  //      Palau    (GMT +9:00)
  '16': 'Pacific/Chuuk' //      Micronesia (GMT +11:00)
};

/** @private */
const timeFormatCache = Object.create(null);

/**
 * Gets a 24-hour time formatter (e.g. 07:41 or 20:03) from cache
 * or makes a new one if needed
 * @private
 * @param {string} tzid
 * @return {Intl.DateTimeFormat}
 */
function getFormatter(tzid) {
  const fmt = timeFormatCache[tzid];
  if (fmt) return fmt;
  const f = new Intl.DateTimeFormat('en-US', {
    timeZone: tzid,
    hour: 'numeric',
    minute: 'numeric',
    hour12: false
  });
  timeFormatCache[tzid] = f;
  return f;
}

/** Class representing Location */
class Location {
  /**
   * Initialize a Location instance
   * @param {number} latitude - Latitude as a decimal, valid range -90 thru +90 (e.g. 41.85003)
   * @param {number} longitude - Longitude as a decimal, valid range -180 thru +180 (e.g. -87.65005)
   * @param {boolean} il - in Israel (true) or Diaspora (false)
   * @param {string} tzid - Olson timezone ID, e.g. "America/Chicago"
   * @param {string} cityName - optional descriptive city name
   * @param {string} countryCode - ISO 3166 alpha-2 country code (e.g. "FR")
   * @param {string} geoid - optional string or numeric geographic ID
   */
  constructor(latitude, longitude, il, tzid, cityName, countryCode, geoid) {
    const lat = typeof latitude === 'number' ? latitude : parseFloat(latitude);
    if (isNaN(lat) || lat < -90 || lat > 90) {
      throw new RangeError(`Latitude ${latitude} out of range [-90,90]`);
    }
    const long = typeof longitude === 'number' ? longitude : parseFloat(longitude);
    if (isNaN(long) || long < -180 || long > 180) {
      throw new RangeError(`Longitude ${longitude} out of range [-180,180]`);
    }
    this.latitude = lat;
    this.longitude = long;
    this.il = Boolean(il);
    this.tzid = tzid;
    this.name = cityName;
    this.cc = countryCode;
    this.geoid = geoid;
  }

  /** @return {number} */
  getLatitude() {
    return this.latitude;
  }

  /** @return {number} */
  getLongitude() {
    return this.longitude;
  }

  /** @return {boolean} */
  getIsrael() {
    return this.il;
  }

  /** @return {string} */
  getName() {
    return this.name;
  }

  /**
   * Returns the location name, up to the first comma
   * @return {string}
   */
  getShortName() {
    const name = this.name;
    if (!name) return name;
    const comma = name.indexOf(', ');
    if (comma === -1) return name;
    if (this.cc === 'US' && name[comma + 2] === 'D') {
      if (name[comma + 3] === 'C') {
        return name.substring(0, comma + 4);
      } else if (name[comma + 3] === '.' && name[comma + 4] === 'C') {
        return name.substring(0, comma + 6);
      }
    }
    return name.substring(0, comma);
  }

  /** @return {string} */
  getCountryCode() {
    return this.cc;
  }

  /** @return {string} */
  getTzid() {
    return this.tzid;
  }

  /**
   * Gets a 24-hour time formatter (e.g. 07:41 or 20:03) for this location
   * @return {Intl.DateTimeFormat}
   */
  getTimeFormatter() {
    return getFormatter(this.tzid);
  }

  /** @return {string} */
  getGeoId() {
    return this.geoid;
  }

  /**
   * Creates a location object from one of 60 "classic" Hebcal city names.
   * The following city names are supported:
   * 'Ashdod', 'Atlanta', 'Austin', 'Baghdad', 'Beer Sheva',
   * 'Berlin', 'Baltimore', 'Bogota', 'Boston', 'Budapest',
   * 'Buenos Aires', 'Buffalo', 'Chicago', 'Cincinnati', 'Cleveland',
   * 'Dallas', 'Denver', 'Detroit', 'Eilat', 'Gibraltar', 'Haifa',
   * 'Hawaii', 'Helsinki', 'Houston', 'Jerusalem', 'Johannesburg',
   * 'Kiev', 'La Paz', 'Livingston', 'Las Vegas', 'London', 'Los Angeles',
   * 'Marseilles', 'Miami', 'Minneapolis', 'Melbourne', 'Mexico City',
   * 'Montreal', 'Moscow', 'New York', 'Omaha', 'Ottawa', 'Panama City',
   * 'Paris', 'Pawtucket', 'Petach Tikvah', 'Philadelphia', 'Phoenix',
   * 'Pittsburgh', 'Providence', 'Portland', 'Saint Louis', 'Saint Petersburg',
   * 'San Diego', 'San Francisco', 'Sao Paulo', 'Seattle', 'Sydney',
   * 'Tel Aviv', 'Tiberias', 'Toronto', 'Vancouver', 'White Plains',
   * 'Washington DC', 'Worcester'
   * @param {string} name
   * @return {Location}
   */
  static lookup(name) {
    return classicCities[name.toLowerCase()];
  }

  /**
   * @deprecated
   * @param {Date|HDate} hdate
   * @return {Date}
   */
  sunset(hdate) {
    return new Zmanim(hdate, this.getLatitude(), this.getLongitude()).sunset();
  }

  /**
   * @deprecated
   * @param {Date|HDate} hdate
   * @param {number} [angle]
   * @return {Date}
   */
  tzeit(hdate, angle) {
    return new Zmanim(hdate, this.getLatitude(), this.getLongitude()).tzeit(angle);
  }

  /** @return {string} */
  toString() {
    return JSON.stringify(this);
  }

  /**
   * Converts legacy Hebcal timezone to a standard Olson tzid.
   * @param {number} tz integer, GMT offset in hours
   * @param {string} dst 'none', 'eu', 'usa', or 'israel'
   * @return {string}
   */
  static legacyTzToTzid(tz, dst) {
    tz = +tz;
    if (dst == 'none') {
      if (tz == 0) {
        return 'UTC';
      } else {
        const plus = tz > 0 ? '+' : '';
        return `Etc/GMT${plus}${tz}`;
      }
    } else if (tz == 2 && dst == 'israel') {
      return 'Asia/Jerusalem';
    } else if (dst == 'eu') {
      switch (tz) {
        case -2:
          return 'Atlantic/Cape_Verde';
        case -1:
          return 'Atlantic/Azores';
        case 0:
          return 'Europe/London';
        case 1:
          return 'Europe/Paris';
        case 2:
          return 'Europe/Athens';
      }
    } else if (dst == 'usa') {
      return ZIPCODES_TZ_MAP[String(tz * -1)];
    }
    return undefined;
  }

  /**
   * Converts timezone info from Zip-Codes.com to a standard Olson tzid.
   * @example
   * Location.getUsaTzid('AZ', 7, 'Y') // 'America/Denver'
   * @param {string} state two-letter all-caps US state abbreviation like 'CA'
   * @param {number} tz positive number, 5=America/New_York, 8=America/Los_Angeles
   * @param {string} dst single char 'Y' or 'N'
   * @return {string}
   */
  static getUsaTzid(state, tz, dst) {
    if (tz == 10 && state == 'AK') {
      return 'America/Adak';
    } else if (tz == 7 && state == 'AZ') {
      return dst == 'Y' ? 'America/Denver' : 'America/Phoenix';
    } else {
      return ZIPCODES_TZ_MAP[tz];
    }
  }

  /**
   * Builds a city description from geonameid string components
   * @deprecated
   * @param {string} cityName e.g. 'Tel Aviv' or 'Chicago'
   * @param {string} admin1 e.g. 'England' or 'Massachusetts'
   * @param {string} countryName full country name, e.g. 'Israel' or 'United States'
   * @return {string}
   */
  static geonameCityDescr(cityName, admin1, countryName) {
    if (countryName == 'United States') countryName = 'USA';
    if (countryName == 'United Kingdom') countryName = 'UK';
    let cityDescr = cityName;
    if (countryName != 'Israel' && admin1 && admin1.indexOf(cityName) != 0) {
      cityDescr += ', ' + admin1;
    }
    if (countryName) {
      cityDescr += ', ' + countryName;
    }
    return cityDescr;
  }

  /**
   * Adds a location name for `Location.lookup()` only if the name isn't
   * already being used. Returns `false` if the name is already taken
   * and `true` if successfully added.
   * @param {string} cityName
   * @param {Location} location
   * @return {boolean}
   */
  static addLocation(cityName, location) {
    const name = cityName.toLowerCase();
    if (classicCities[name]) {
      return false;
    }
    classicCities[name] = location;
    return true;
  }
}
classicCities0.forEach(city => {
  const location = new Location(city[2], city[3], city[1] == 'IL', city[4], city[0], city[1]);
  Location.addLocation(location.getName(), location);
});

/* eslint-disable max-len */
const days = {
  FRI: 5,
  SAT: 6
};

/**
 * @private
 * @constant
 * This method returns the tzais (nightfall) based on the opinion of the
 * Geonim calculated as 30 minutes after sunset during the equinox
 * (on March 16, about 4 days before the astronomical equinox, the day that
 * a solar hour is 60 minutes) in Yerushalayim.
 * @see {https://kosherjava.com/zmanim/docs/api/com/kosherjava/zmanim/ComplexZmanimCalendar.html#getTzaisGeonim7Point083Degrees()}
 */
const TZEIT_3MEDIUM_STARS = 7.083;

/**
 * @private
 * @param {Event} e
 * @param {HDate} hd
 * @param {number} dow
 * @param {Location} location
 * @param {CalOptions} options
 * @return {Event}
 */
function makeCandleEvent(e, hd, dow, location, options) {
  let havdalahTitle = false;
  let useHavdalahOffset = dow == days.SAT;
  let mask = e ? e.getFlags() : flags.LIGHT_CANDLES;
  if (typeof e !== 'undefined') {
    // if linked event && dow == FRI, use Candle lighting time & title
    if (dow != days.FRI) {
      if (mask & (flags.LIGHT_CANDLES_TZEIS | flags.CHANUKAH_CANDLES)) {
        useHavdalahOffset = true;
      } else if (mask & flags.YOM_TOV_ENDS) {
        havdalahTitle = true;
        useHavdalahOffset = true;
      }
    }
  } else if (dow == days.SAT) {
    havdalahTitle = true;
    mask = flags.LIGHT_CANDLES_TZEIS;
  }
  // if offset is 0 or undefined, we'll use tzeit time
  const offset = useHavdalahOffset ? options.havdalahMins : options.candleLightingMins;
  const zmanim = new Zmanim(hd, location.getLatitude(), location.getLongitude());
  const time = offset ? zmanim.sunsetOffset(offset, true) : zmanim.tzeit(options.havdalahDeg);
  if (isNaN(time.getTime())) {
    return null; // no sunset
  }

  if (havdalahTitle) {
    return new HavdalahEvent(hd, mask, time, location, options.havdalahMins, e);
  } else {
    return new CandleLightingEvent(hd, mask, time, location, e);
  }
}

/** An event that has an `eventTime` and `eventTimeStr` */
class TimedEvent extends Event {
  /**
   * @param {HDate} date
   * @param {string} desc Description (not translated)
   * @param {number} mask
   * @param {Date} eventTime
   * @param {Location} location
   * @param {Event} linkedEvent
   */
  constructor(date, desc, mask, eventTime, location, linkedEvent) {
    super(date, desc, mask);
    this.eventTime = Zmanim.roundTime(eventTime);
    this.location = location;
    const timeFormat = location.getTimeFormatter();
    this.eventTimeStr = Zmanim.formatTime(this.eventTime, timeFormat);
    if (typeof linkedEvent !== 'undefined') {
      this.linkedEvent = linkedEvent;
    }
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    return Locale.gettext(this.getDesc(), locale) + ': ' + this.eventTimeStr;
  }
  /**
   * Returns translation of "Candle lighting" without the time.
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  renderBrief(locale) {
    return Locale.gettext(this.getDesc(), locale);
  }
  /** @return {string[]} */
  getCategories() {
    const desc = this.getDesc();
    switch (desc) {
      // LIGHT_CANDLES or LIGHT_CANDLES_TZEIS
      case 'Candle lighting':
        return ['candles'];
      // YOM_TOV_ENDS
      case 'Havdalah':
        return ['havdalah'];
      // flags.MINOR_FAST or flags.MAJOR_FAST
      case 'Fast begins':
      case 'Fast ends':
        return ['zmanim', 'fast'];
    }
  }
}

/** Havdalah after Shabbat or holiday */
class HavdalahEvent extends TimedEvent {
  /**
   * @param {HDate} date
   * @param {number} mask
   * @param {Date} eventTime
   * @param {Location} location
   * @param {number} havdalahMins
   * @param {Event} linkedEvent
   */
  constructor(date, mask, eventTime, location, havdalahMins, linkedEvent) {
    super(date, 'Havdalah', mask, eventTime, location, linkedEvent);
    if (havdalahMins) {
      this.havdalahMins = havdalahMins;
    }
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    return this.renderBrief(locale) + ': ' + this.eventTimeStr;
  }
  /**
   * Returns translation of "Havdalah" without the time.
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  renderBrief(locale) {
    let str = Locale.gettext(this.getDesc(), locale);
    if (this.havdalahMins) {
      const min = Locale.gettext('min', locale);
      str += ` (${this.havdalahMins} ${min})`;
    }
    return str;
  }
  /** @return {string} */
  getEmoji() {
    return '✨';
  }
}

/** Candle lighting before Shabbat or holiday */
class CandleLightingEvent extends TimedEvent {
  /**
   * @param {HDate} date
   * @param {number} mask
   * @param {Date} eventTime
   * @param {Location} location
   * @param {Event} linkedEvent
   */
  constructor(date, mask, eventTime, location, linkedEvent) {
    super(date, 'Candle lighting', mask, eventTime, location, linkedEvent);
  }
  /** @return {string} */
  getEmoji() {
    return '🕯️';
  }
}

/**
 * Makes a pair of events representing fast start and end times
 * @private
 * @param {Event} ev
 * @param {Location} location
 * @return {Event}
 */
function makeFastStartEnd(ev, location) {
  const desc = ev.getDesc();
  if (desc === 'Yom Kippur') {
    return ev;
  }
  ev = ev.clone();
  const hd = ev.getDate();
  const dt = hd.greg();
  const zmanim = new Zmanim(dt, location.getLatitude(), location.getLongitude());
  if (desc === 'Erev Tish\'a B\'Av') {
    const sunset = zmanim.sunset();
    ev.startEvent = makeTimedEvent(hd, sunset, 'Fast begins', ev, location);
  } else if (desc.substring(0, 11) === 'Tish\'a B\'Av') {
    ev.endEvent = makeTimedEvent(hd, zmanim.tzeit(TZEIT_3MEDIUM_STARS), 'Fast ends', ev, location);
  } else {
    const dawn = zmanim.alotHaShachar();
    ev.startEvent = makeTimedEvent(hd, dawn, 'Fast begins', ev, location);
    if (dt.getDay() !== 5 && !(hd.getDate() === 14 && hd.getMonth() === months.NISAN)) {
      ev.endEvent = makeTimedEvent(hd, zmanim.tzeit(TZEIT_3MEDIUM_STARS), 'Fast ends', ev, location);
    }
  }
  return ev;
}

/**
 * @private
 * @param {HDate} hd
 * @param {Date} time
 * @param {string} desc
 * @param {Event} ev
 * @param {Location} location
 * @return {TimedEvent}
 */
function makeTimedEvent(hd, time, desc, ev, location) {
  if (isNaN(time.getTime())) {
    return null;
  }
  return new TimedEvent(hd, desc, ev.getFlags(), time, location, ev);
}

/**
 * Makes a candle-lighting event for Chankah (not on Friday/Saturday)
 * @private
 * @param {Event} ev
 * @param {HDate} hd
 * @param {Location} location
 * @return {TimedEvent}
 */
function makeWeekdayChanukahCandleLighting(ev, hd, location) {
  const zmanim = new Zmanim(hd.greg(), location.getLatitude(), location.getLongitude());
  const candleLightingTime = zmanim.dusk();
  // const candleLightingTime = zmanim.tzeit(4.6667);
  return makeTimedEvent(hd, candleLightingTime, ev.getDesc(), ev, location);
}

/* eslint-disable camelcase */
const shortDayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

/**
 * Represents a molad, the moment when the new moon is "born"
 */
class Molad {
  /**
   * Calculates the molad for a Hebrew month
   * @param {number} year
   * @param {number} month
   */
  constructor(year, month) {
    let m_adj = month - 7;
    if (m_adj < 0) {
      m_adj += HDate.monthsInYear(year);
    }
    const m_elapsed = 235 * Math.floor((year - 1) / 19) +
    // Months in complete 19 year lunar (Metonic) cycles so far
    12 * ((year - 1) % 19) +
    // Regular months in this cycle
    Math.floor((7 * ((year - 1) % 19) + 1) / 19) +
    // Leap months this cycle
    m_adj; // add elapsed months till the start of the molad of the month

    const p_elapsed = 204 + Math.floor(793 * (m_elapsed % 1080));
    const h_elapsed = 5 + 12 * m_elapsed + 793 * Math.floor(m_elapsed / 1080) + Math.floor(p_elapsed / 1080) - 6;
    const parts = p_elapsed % 1080 + 1080 * (h_elapsed % 24);
    const chalakim = parts % 1080;
    const day = 1 + 29 * m_elapsed + Math.floor(h_elapsed / 24);
    const dow = day % 7;
    this.year = year;
    this.month = month;
    this.dow = dow;
    this.hour = h_elapsed % 24;
    this.minutes = Math.floor(chalakim / 18);
    this.chalakim = chalakim % 18;
  }
  /**
   * @return {number}
   */
  getYear() {
    return this.year;
  }
  /**
   * @return {number}
   */
  getMonth() {
    return this.month;
  }
  /**
   * @return {string}
   */
  getMonthName() {
    return HDate.getMonthName(this.month, this.year);
  }
  /**
   * @return {number} Day of Week (0=Sunday, 6=Saturday)
   */
  getDow() {
    return this.dow;
  }
  /**
   * @return {number} hour of day (0-23)
   */
  getHour() {
    return this.hour;
  }
  /**
   * @return {number} minutes past hour (0-59)
   */
  getMinutes() {
    return this.minutes;
  }
  /**
   * @return {number} parts of a minute (0-17)
   */
  getChalakim() {
    return this.chalakim;
  }
}

/** Represents a Molad announcement on Shabbat Mevarchim */
class MoladEvent extends Event {
  /**
   * @param {HDate} date Hebrew date event occurs
   * @param {number} hyear molad year
   * @param {number} hmonth molad month
   */
  constructor(date, hyear, hmonth) {
    const m = new Molad(hyear, hmonth);
    const monthName = m.getMonthName();
    super(date, `Molad ${monthName} ${hyear}`, flags.MOLAD);
    this.molad = m;
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    const m = this.molad;
    const monthName = m.getMonthName();
    const dow = shortDayNames[m.getDow()];
    const minutes = m.getMinutes();
    const hour = m.getHour();
    const chalakim = m.getChalakim();
    return `Molad ${monthName}: ${dow}, ${minutes} minutes and ${chalakim} chalakim after ${hour}:00`;
  }
}

const sefirot = [null, 'Lovingkindness', 'Might', 'Beauty', 'Eternity', 'Splendor', 'Foundation', 'Majesty'];
const sefirotTranslit = [null, 'Chesed', 'Gevurah', 'Tiferet', 'Netzach', 'Hod', 'Yesod', 'Malkhut'];

/** Represents a day 1-49 of counting the Omer from Pesach to Shavuot */
class OmerEvent extends Event {
  /**
   * @param {HDate} date
   * @param {number} omerDay
   */
  constructor(date, omerDay) {
    super(date, `Omer ${omerDay}`, flags.OMER_COUNT);
    if (omerDay < 1 || omerDay > 49) {
      throw new RangeError(`Invalid Omer day ${omerDay}`);
    }
    this.weekNumber = Math.floor((omerDay - 1) / 7) + 1;
    this.daysWithinWeeks = omerDay % 7 || 7;
    this.omer = omerDay;
  }
  /**
   * @param {string} lang
   * @return {string}
   */
  sefira(lang = 'en') {
    const week = sefirot[this.weekNumber];
    const dayWithinWeek = sefirot[this.daysWithinWeeks];
    switch (lang) {
      case 'he':
        const heWeek = Locale.gettext(week, 'he');
        const heDayWithinWeek = Locale.gettext(dayWithinWeek, 'he');
        const hePrefix = this.weekNumber === 2 || this.weekNumber === 6 ? 'שֶׁבִּ' : 'שֶׁבְּ';
        return `${heDayWithinWeek} ${hePrefix}${heWeek}`.normalize();
      case 'translit':
        const translitWeek = sefirotTranslit[this.weekNumber];
        const translitDayWithinWeek = sefirotTranslit[this.daysWithinWeeks];
        const translitPrefix = this.weekNumber === 2 || this.weekNumber === 6 ? 'shebi' : `sheb'`;
        return `${translitDayWithinWeek} ${translitPrefix}${translitWeek}`;
      case 'en':
      default:
        return `${dayWithinWeek} within ${week}`;
    }
  }
  /**
   * @todo use gettext()
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    locale = locale || Locale.getLocaleName();
    const omer = this.omer;
    const nth = locale == 'he' ? gematriya(omer) : Locale.ordinal(omer, locale);
    return nth + ' ' + Locale.gettext('day of the Omer', locale);
  }
  /**
   * Returns translation of "Omer day 22" without ordinal numbers.
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  renderBrief(locale) {
    return Locale.gettext('Omer', locale) + ' ' + Locale.gettext('day', locale) + ' ' + this.omer;
  }
  /** @return {string} */
  getEmoji() {
    if (typeof this.emoji === 'string') return this.emoji;
    const number = this.omer;
    if (number <= 20) {
      return String.fromCodePoint(9312 + number - 1);
    } else if (number <= 35) {
      // between 21 and 35 inclusive
      return String.fromCodePoint(12881 + number - 21);
    } else {
      // between 36 and 49 inclusive
      return String.fromCodePoint(12977 + number - 36);
    }
  }
  /** @return {number} */
  getWeeks() {
    const day7 = this.daysWithinWeeks === 7;
    return day7 ? this.weekNumber : this.weekNumber - 1;
  }
  /** @return {number} */
  getDaysWithinWeeks() {
    return this.daysWithinWeeks;
  }
  /**
   * @param {string} locale
   * @return {string}
   */
  getTodayIs(locale) {
    locale = locale || Locale.getLocaleName();
    if (typeof locale === 'string') {
      locale = locale.toLowerCase();
    }
    if (locale === 'he') {
      return getTodayIsHe(this.omer);
    } else if (locale === 'he-x-nonikud') {
      return Locale.hebrewStripNikkud(getTodayIsHe(this.omer));
    }
    const totalDaysStr = this.omer === 1 ? 'day' : 'days';
    let str = `Today is ${this.omer} ${totalDaysStr}`;
    if (this.weekNumber > 1 || this.omer === 7) {
      const day7 = this.daysWithinWeeks === 7;
      const numWeeks = day7 ? this.weekNumber : this.weekNumber - 1;
      const weeksStr = numWeeks === 1 ? 'week' : 'weeks';
      str += `, which is ${numWeeks} ${weeksStr}`;
      if (!day7) {
        const daysStr = this.daysWithinWeeks === 1 ? 'day' : 'days';
        str += ` and ${this.daysWithinWeeks} ${daysStr}`;
      }
    }
    return str + ' of the Omer';
  }
  /** @return {string} */
  url() {
    return `https://www.hebcal.com/omer/${this.getDate().getFullYear()}/${this.omer}`;
  }
}

// adapted from pip hdate package (GPL)
// https://github.com/py-libhdate/py-libhdate/blob/master/hdate/date.py

const tens = ['', 'עֲשָׂרָה', 'עֶשְׂרִים', 'שְׁלוֹשִׁים', 'אַרְבָּעִים'];
const ones = ['', 'אֶחָד', 'שְׁנַיִם', 'שְׁלוֹשָׁה', 'אַרְבָּעָה', 'חֲמִשָׁה', 'שִׁשָׁה', 'שִׁבְעָה', 'שְׁמוֹנָה', 'תִּשְׁעָה'];
const shnei = 'שְׁנֵי';
const yamim = 'יָמִים';
const shneiYamim = shnei + ' ' + yamim;
const shavuot = 'שָׁבוּעוֹת';
const yom = 'יוֹם';
const yomEchad = yom + ' ' + ones[1];

/**
 * @private
 * @param {number} omer
 * @return {string}
 */
function getTodayIsHe(omer) {
  const ten = Math.floor(omer / 10);
  const one = omer % 10;
  let str = 'הַיוֹם ';
  if (10 < omer && omer < 20) {
    str += ones[one] + ' עָשָׂר';
  } else if (omer > 9) {
    str += ones[one];
    if (one) {
      str += ' וְ';
    }
  }
  if (omer > 2) {
    if (omer > 20 || omer === 10 || omer === 20) {
      str += tens[ten];
    }
    if (omer < 11) {
      str += ones[one] + ' ' + yamim + ' ';
    } else {
      str += ' ' + yom + ' ';
    }
  } else if (omer === 1) {
    str += yomEchad + ' ';
  } else {
    // omer == 2
    str += shneiYamim + ' ';
  }
  if (omer > 6) {
    str = str.trim(); // remove trailing space before comma
    str += ', שְׁהֵם ';
    const weeks = Math.floor(omer / 7);
    const days = omer % 7;
    if (weeks > 2) {
      str += ones[weeks] + ' ' + shavuot + ' ';
    } else if (weeks == 1) {
      str += 'שָׁבוּעַ' + ' ' + ones[1] + ' ';
    } else {
      // weeks == 2
      str += shnei + ' ' + shavuot + ' ';
    }
    if (days) {
      str += 'וְ';
      if (days > 2) {
        str += ones[days] + ' ' + yamim + ' ';
      } else if (days == 1) {
        str += yomEchad + ' ';
      } else {
        // days == 2
        str += shneiYamim + ' ';
      }
    }
  }
  str += 'לָעוֹמֶר';
  return str.normalize();
}

/* eslint-disable new-cap */
/*
    Hebcal - A Jewish Calendar Generator
    Copyright (c) 1994-2020 Danny Sadinoff
    Portions copyright Eyal Schachter and Michael J. Radwin

    https://github.com/hebcal/hebcal-es6

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

const INCOMPLETE = 0;
const REGULAR = 1;
const COMPLETE = 2;

// eslint-disable-next-line require-jsdoc
function throwError(errorMessage) {
  throw new TypeError(errorMessage);
}

/**
 * Result of Sedra.lookup
 * @typedef {Object} SedraResult
 * @property {string[]} parsha Name of the parsha (or parshiyot) read on
 *     Hebrew date, e.g. `['Noach']` or `['Matot', 'Masei']`
 * @property {boolean} chag True if this is a regular parasha HaShavua
 *     Torah reading, false if it's a special holiday reading
 * @property {number|number[]} num the parsha number (or numbers) using 1-indexing.
 *     A `number` for a regular (single) parsha, and a `number[]` for a doubled parsha.
 *     For Parashat *Bereshit*, `num` would be equal to `1`, and for
 *     *Matot-Masei* it would be `[42, 43]`
 */

/**
 * Represents Parashah HaShavua for an entire Hebrew year
 */
class Sedra {
  /**
   * Caculates the Parashah HaShavua for an entire Hebrew year
   * @param {number} hebYr - Hebrew year (e.g. 5749)
   * @param {boolean} il - Use Israel sedra schedule (false for Diaspora)
   */
  constructor(hebYr, il) {
    // the Hebrew year
    hebYr = +hebYr;
    const longC = HDate.longCheshvan(hebYr);
    const shortK = HDate.shortKislev(hebYr);
    const type = this.type = longC && !shortK ? COMPLETE : !longC && shortK ? INCOMPLETE : REGULAR;
    this.year = hebYr;
    const rh0 = new HDate(1, months.TISHREI, hebYr);
    const rh = rh0.abs();
    const rhDay = this.roshHashanaDay = rh0.getDay() + 1;

    // find the first Saturday on or after Rosh Hashana
    this.firstSaturday = HDate.dayOnOrBefore(6, rh + 6);
    const leap = this.leap = +HDate.isLeapYear(hebYr);
    this.il = Boolean(il);
    const key = `${leap}${rhDay}${type}`;
    if (types[key]) {
      this.key = key;
      this.theSedraArray = types[key];
    } else {
      const key2 = this.key = key + +this.il; // cast to num, then concat
      this.theSedraArray = types[key2];
    }
    if (!this.theSedraArray) {
      throw new Error(`improper sedra year type ${this.key} calculated for ${hebYr}`);
    }
  }

  /**
   * Returns the parsha (or parshiyot) read on Hebrew date
   * @param {HDate|number} hDate Hebrew date or R.D. days
   * @return {string[]}
   */
  get(hDate) {
    return this.lookup(hDate).parsha;
  }

  /**
   * Looks up parsha for the date, then returns a translated or transliterated string
   * @param {HDate|number} hDate Hebrew date or R.D. days
   * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale
   * @return {string}
   */
  getString(hDate, locale) {
    const parsha = this.get(hDate);
    const locale0 = locale || Locale.getLocaleName();
    let name = Locale.gettext(parsha[0], locale0);
    if (parsha.length == 2) {
      const hyphen = locale0 == 'he' ? '־' : '-';
      name += hyphen + Locale.gettext(parsha[1], locale0);
    }
    return Locale.gettext('Parashat', locale0) + ' ' + name;
  }

  /**
   * Checks to see if this day would be a regular parasha HaShavua
   * Torah reading or special holiday reading
   * @param {HDate|number} hDate Hebrew date or R.D. days
   * @return {boolean}
   */
  isParsha(hDate) {
    return !this.lookup(hDate).chag;
  }

  /**
   * Returns the date that a parsha occurs
   * @param {number|string|string[]} parsha
   * @return {HDate}
   */
  find(parsha) {
    if (typeof parsha === 'number') {
      if (parsha > 53 || parsha < 0 && !isValidDouble(parsha)) {
        throw new RangeError(`Invalid parsha number: ${parsha}`);
      }
      const idx = this.theSedraArray.indexOf(parsha);
      if (idx === -1) {
        return null; // doesn't occur this year
      }

      return new HDate(this.firstSaturday + idx * 7);
    } else if (typeof parsha === 'string') {
      const num = parsha2id[parsha];
      if (typeof num === 'number') {
        return this.find(num);
      } else if (parsha.indexOf('-') !== -1) {
        return this.find(parsha.split('-'));
      } else {
        // try to find Saturday holiday like 'Yom Kippur'
        const idx = this.theSedraArray.indexOf(parsha);
        if (idx === -1) {
          return null; // doesn't occur this year
        }

        return new HDate(this.firstSaturday + idx * 7);
      }
    } else if (Array.isArray(parsha) && parsha.length === 1 && typeof parsha[0] === 'string') {
      return this.find(parsha[0]);
    } else if (Array.isArray(parsha) && parsha.length === 2 && typeof parsha[0] === 'string' && typeof parsha[1] === 'string') {
      const p1 = parsha[0];
      const p2 = parsha[1];
      const num1 = parsha2id[p1];
      const num2 = parsha2id[p2];
      if (num2 === num1 + 1) {
        return this.find(-num1);
      } else {
        throw new RangeError(`Unrecognized parsha name: ${p1}-${p2}`);
      }
    } else {
      throw new TypeError(`Invalid parsha argument: ${parsha}`);
    }
  }

  /**
   * @private
   * @return {Object[]}
   */
  getSedraArray() {
    return this.theSedraArray;
  }

  /**
   * R.D. date of the first Saturday on or after Rosh Hashana
   * @return {number}
   */
  getFirstSaturday() {
    return this.firstSaturday;
  }

  /** @return {number} */
  getYear() {
    return this.year;
  }

  /**
   * Returns an object describing the parsha on the first Saturday on or after absdate
   * @param {HDate|number} hDate Hebrew date or R.D. days
   * @return {SedraResult}
   */
  lookup(hDate) {
    const absDate = typeof hDate === 'number' ? hDate : HDate.isHDate(hDate) ? hDate.abs() : throwError(`Bad date argument: ${hDate}`);

    // find the first saturday on or after today's date
    const saturday = HDate.dayOnOrBefore(6, absDate + 6);
    const weekNum = (saturday - this.firstSaturday) / 7;
    const index = this.theSedraArray[weekNum];
    if (typeof index === 'undefined') {
      const sedra = new Sedra(this.year + 1, this.il);
      return sedra.lookup(saturday); // must be next year
    }

    if (typeof index === 'string') {
      // Shabbat has a chag. Return a description
      return {
        parsha: [index],
        chag: true
      };
    }
    if (index >= 0) {
      return {
        parsha: [parshiot[index]],
        chag: false,
        num: index + 1
      };
    }
    const p1 = D(index); // undouble the parsha
    return {
      parsha: [parshiot[p1], parshiot[p1 + 1]],
      chag: false,
      num: [p1 + 1, p1 + 2]
    };
  }
}

/**
 * The 54 parshiyot of the Torah as transilterated strings
 * parshiot[0] == 'Bereshit', parshiot[1] == 'Noach', parshiot[53] == "Ha'Azinu".
 * @readonly
 * @type {string[]}
 */
const parshiot = ['Bereshit', 'Noach', 'Lech-Lecha', 'Vayera', 'Chayei Sara', 'Toldot', 'Vayetzei', 'Vayishlach', 'Vayeshev', 'Miketz', 'Vayigash', 'Vayechi', 'Shemot', 'Vaera', 'Bo', 'Beshalach', 'Yitro', 'Mishpatim', 'Terumah', 'Tetzaveh', 'Ki Tisa', 'Vayakhel', 'Pekudei', 'Vayikra', 'Tzav', 'Shmini', 'Tazria', 'Metzora', 'Achrei Mot', 'Kedoshim', 'Emor', 'Behar', 'Bechukotai', 'Bamidbar', 'Nasso', 'Beha\'alotcha', 'Sh\'lach', 'Korach', 'Chukat', 'Balak', 'Pinchas', 'Matot', 'Masei', 'Devarim', 'Vaetchanan', 'Eikev', 'Re\'eh', 'Shoftim', 'Ki Teitzei', 'Ki Tavo', 'Nitzavim', 'Vayeilech', 'Ha\'Azinu'];
const parsha2id = {};
for (let id = 0; id < parshiot.length; id++) {
  const name = parshiot[id];
  parsha2id[name] = id;
}

/**
 * @private
 * @param {number} id
 * @return {boolean}
 */
function isValidDouble(id) {
  switch (id) {
    case -21: // Vayakhel-Pekudei
    case -26: // Tazria-Metzora
    case -28: // Achrei Mot-Kedoshim
    case -31: // Behar-Bechukotai
    case -38: // Chukat-Balak
    case -41: // Matot-Masei
    case -50:
      // Nitzavim-Vayeilech
      return true;
  }
  return false;
}

/**
 * @private
 * @param {number} p
 * @return {number}
 */
function D(p) {
  // parsha doubler/undoubler
  return -p;
}
const RH = 'Rosh Hashana'; // 0
const YK = 'Yom Kippur'; // 1

const SUKKOT = 'Sukkot'; // 0
const CHMSUKOT = 'Sukkot Shabbat Chol ha-Moed'; // 0
const SHMINI = 'Shmini Atzeret'; // 0
const EOY = CHMSUKOT; // always Sukkot day 3, 5 or 6

const PESACH = 'Pesach'; // 25
const PESACH1 = 'Pesach I';
const CHMPESACH = 'Pesach Shabbat Chol ha-Moed'; // 25
const PESACH7 = 'Pesach VII'; // 25
const PESACH8 = 'Pesach VIII';
const SHAVUOT = 'Shavuot'; // 33

/**
 * Returns an array from start to end
 * @private
 * @param {number} start beginning number, inclusive
 * @param {number} stop ending number, inclusive
 * @return {number[]}
 */
function range$1(start, stop) {
  return Array.from({
    length: stop - start + 1
  }, (v, k) => k + start);
}

/**
 * The ordinary year types (keviot)
 * names are leap/nonleap - day - incomplete/regular/complete - diaspora/Israel
 * @private
 * @readonly
 * @type {Object.<string, Object[]>}
 */
const types = {
  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and
     * Kislev each have 29 days), and has Passover start on Tuesday. */
  // e.g. 5753
  '020': [51, 52].concat(EOY, range$1(0, 20), D(21), 23, 24, PESACH, 25, D(26), D(28), 30, D(31), range$1(33, 40), D(41), range$1(43, 49), D(50)),
  /* Hebrew year that starts on Monday, is `complete' (Heshvan and
     * Kislev each have 30 days), and has Passover start on Thursday. */
  // e.g. 5756
  '0220': [51, 52].concat(EOY, range$1(0, 20), D(21), 23, 24, PESACH, 25, D(26), D(28), 30, D(31), 33, SHAVUOT, range$1(34, 37), D(38), 40, D(41), range$1(43, 49), D(50)),
  /* Hebrew year that starts on Thursday, is `regular' (Heshvan has 29
     * days and Kislev has 30 days), and has Passover start on Saturday. */
  // e.g. 5701
  '0510': [52].concat(YK, EOY, range$1(0, 20), D(21), 23, 24, PESACH1, PESACH8, 25, D(26), D(28), 30, D(31), range$1(33, 40), D(41), range$1(43, 50)),
  /* Hebrew year that starts on Thursday, is `regular' (Heshvan has 29
     * days and Kislev has 30 days), and has Passover start on Saturday. */
  // e.g. 5745
  '0511': [52].concat(YK, EOY, range$1(0, 20), D(21), 23, 24, PESACH, 25, D(26), D(28), range$1(30, 40), D(41), range$1(43, 50)),
  /* Hebrew year that starts on Thursday, is `complete' (Heshvan and
     * Kislev each have 30 days), and has Passover start on Sunday. */
  // e.g. 5754
  '052': [52].concat(YK, CHMSUKOT, range$1(0, 24), PESACH7, 25, D(26), D(28), 30, D(31), range$1(33, 40), D(41), range$1(43, 50)),
  /* Hebrew year that starts on Saturday, is `incomplete' (Heshvan and Kislev
     * each have 29 days), and has Passover start on Sunday. */
  // e.g. 5761
  '070': [].concat(RH, 52, SUKKOT, SHMINI, range$1(0, 20), D(21), 23, 24, PESACH7, 25, D(26), D(28), 30, D(31), range$1(33, 40), D(41), range$1(43, 50)),
  /* Hebrew year that starts on Saturday, is `complete' (Heshvan and
     * Kislev each have 30 days), and has Passover start on Tuesday. */
  // e.g. 5716
  '072': [].concat(RH, 52, SUKKOT, SHMINI, range$1(0, 20), D(21), 23, 24, CHMPESACH, 25, D(26), D(28), 30, D(31), range$1(33, 40), D(41), range$1(43, 49), D(50)),
  /* --  The leap year types (keviot) -- */
  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and
     * Kislev each have 29 days), and has Passover start on Thursday. */
  // e.g. 5746
  '1200': [51, 52].concat(CHMSUKOT, range$1(0, 27), CHMPESACH, range$1(28, 33), SHAVUOT, range$1(34, 37), D(38), 40, D(41), range$1(43, 49), D(50)),
  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and
     * Kislev each have 29 days), and has Passover start on Thursday. */
  // e.g. 5746
  '1201': [51, 52].concat(CHMSUKOT, range$1(0, 27), CHMPESACH, range$1(28, 40), D(41), range$1(43, 49), D(50)),
  /* Hebrew year that starts on Monday, is `complete' (Heshvan and
     * Kislev each have 30 days), and has Passover start on Saturday. */
  // e.g.5752
  '1220': [51, 52].concat(CHMSUKOT, range$1(0, 27), PESACH1, PESACH8, range$1(28, 40), D(41), range$1(43, 50)),
  /* Hebrew year that starts on Monday, is `complete' (Heshvan and
     * Kislev each have 30 days), and has Passover start on Saturday. */
  // e.g.5752
  '1221': [51, 52].concat(CHMSUKOT, range$1(0, 27), PESACH, range$1(28, 50)),
  /* Hebrew year that starts on Thursday, is `incomplete' (Heshvan and
     * Kislev both have 29 days), and has Passover start on Sunday. */
  // e.g. 5768
  '150': [52].concat(YK, CHMSUKOT, range$1(0, 28), PESACH7, range$1(29, 50)),
  /* Hebrew year that starts on Thursday, is `complete' (Heshvan and
     * Kislev both have 30 days), and has Passover start on Tuesday. */
  // eg. 5771
  '152': [52].concat(YK, CHMSUKOT, range$1(0, 28), CHMPESACH, range$1(29, 49), D(50)),
  /* Hebrew year that starts on Saturday, is `incomplete' (Heshvan and
     * Kislev each have 29 days), and has Passover start on Tuesday. */
  // e.g.5757
  '170': [].concat(RH, 52, SUKKOT, SHMINI, range$1(0, 27), CHMPESACH, range$1(28, 40), D(41), range$1(43, 49), D(50)),
  /* Hebrew year that starts on Saturday, is `complete' (Heshvan and
     * Kislev each have 30 days), and has Passover start on Thursday. */
  '1720': [].concat(RH, 52, SUKKOT, SHMINI, range$1(0, 27), CHMPESACH, range$1(28, 33), SHAVUOT, range$1(34, 37), D(38), 40, D(41), range$1(43, 49), D(50))
};

/* Hebrew year that starts on Monday, is `complete' (Heshvan and
 * Kislev each have 30 days), and has Passover start on Thursday. */
types['0221'] = types['020'];

/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29
 * days and Kislev has 30 days), and has Passover start on Thursday. */
// e.g. 5715
types['0310'] = types['0220'];

/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29
 * days and Kislev has 30 days), and has Passover start on Thursday. */
types['0311'] = types['020'];

/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29
 * days and Kislev has 30 days), and has Passover start on Saturday. */
// e.g. 5715
types['1310'] = types['1220'];
/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29
 * days and Kislev has 30 days), and has Passover start on Saturday. */
types['1311'] = types['1221'];

/* Hebrew year that starts on Saturday, is `complete' (Heshvan and
 * Kislev each have 30 days), and has Passover start on Thursday. */
types['1721'] = types['170'];

/**
 * Represents one of 54 weekly Torah portions, always on a Saturday
 */
class ParshaEvent extends Event {
  /**
   * @param {HDate} date
   * @param {string[]} parsha - untranslated name of single or double parsha,
   *   such as ['Bereshit'] or ['Achrei Mot', 'Kedoshim']
   * @param {boolean} il
   * @param {number|number[]} num
   */
  constructor(date, parsha, il, num) {
    if (!Array.isArray(parsha) || parsha.length === 0 || parsha.length > 2) {
      throw new TypeError('Bad parsha argument');
    }
    const desc = 'Parashat ' + parsha.join('-');
    super(date, desc, flags.PARSHA_HASHAVUA);
    this.parsha = parsha;
    this.il = Boolean(il);
    this.num = num || -1;
  }
  /**
   * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
   * @return {string}
   */
  render(locale) {
    const locale0 = locale || Locale.getLocaleName();
    const parsha = this.parsha;
    let name = Locale.gettext(parsha[0], locale);
    if (parsha.length == 2) {
      const hyphen = locale0 == 'he' ? '־' : '-';
      name += hyphen + Locale.gettext(parsha[1], locale);
    }
    const str = Locale.gettext('Parashat', locale) + ' ' + name;
    return str.normalize();
  }
  /** @return {string} */
  basename() {
    return this.parsha.join('-');
  }
  /** @return {string} */
  url() {
    const year = this.getDate().greg().getFullYear();
    if (year < 100) {
      return undefined;
    }
    const dt = this.urlDateSuffix();
    const url = 'https://www.hebcal.com/sedrot/' + this.basename().toLowerCase().replace(/'/g, '').replace(/ /g, '-') + '-' + dt;
    return this.il ? url + '?i=on' : url;
  }

  /** @return {string} */
  urlDateSuffix() {
    const isoDateTime = this.getDate().greg().toISOString();
    const isoDate = isoDateTime.substring(0, isoDateTime.indexOf('T'));
    return isoDate.replace(/-/g, '');
  }
}

const SUN$1 = 0;
const TUE$1 = 2;
const FRI$2 = 5;
const SAT$2 = 6;
const NISAN$3 = months.NISAN;
const IYYAR = months.IYYAR;

/**
 * Yom HaShoah first observed in 1951.
 * When the actual date of Yom Hashoah falls on a Friday, the
 * state of Israel observes Yom Hashoah on the preceding
 * Thursday. When it falls on a Sunday, Yom Hashoah is observed
 * on the following Monday.
 * http://www.ushmm.org/remembrance/dor/calendar/
 * @private
 * @param {number} year
 * @return {HDate|null}
 */
function dateYomHaShoah(year) {
  if (year < 5711) {
    return null;
  }
  let nisan27dt = new HDate(27, NISAN$3, year);
  if (nisan27dt.getDay() === FRI$2) {
    nisan27dt = new HDate(26, NISAN$3, year);
  } else if (nisan27dt.getDay() === SUN$1) {
    nisan27dt = new HDate(28, NISAN$3, year);
  }
  return nisan27dt;
}

/**
 * Yom HaAtzma'ut only celebrated after 1948
 * @private
 * @param {number} year
 * @return {HDate|null}
 */
function dateYomHaZikaron(year) {
  if (year < 5708) {
    return null;
  }
  let day;
  const pesach = new HDate(15, NISAN$3, year);
  const pdow = pesach.getDay();
  if (pdow === SUN$1) {
    day = 2;
  } else if (pdow === SAT$2) {
    day = 3;
  } else if (year < 5764) {
    day = 4;
  } else if (pdow === TUE$1) {
    day = 5;
  } else {
    day = 4;
  }
  return new HDate(day, IYYAR, year);
}

const Nisan = months.NISAN;
const Iyyar = months.IYYAR;
const Sivan = months.SIVAN;
const Tamuz = months.TAMUZ;
const Av = months.AV;
const Elul = months.ELUL;
const Tishrei = months.TISHREI;
const Cheshvan = months.CHESHVAN;
const Kislev = months.KISLEV;
// const Tevet = months.TEVET;
const Shvat = months.SHVAT;
// const Adar1 = months.ADAR_I;
const Adar2 = months.ADAR_II;
const CHAG$1 = flags.CHAG;
const LIGHT_CANDLES$1 = flags.LIGHT_CANDLES;
const YOM_TOV_ENDS$1 = flags.YOM_TOV_ENDS;
const CHUL_ONLY$1 = flags.CHUL_ONLY;
const IL_ONLY$1 = flags.IL_ONLY;
const LIGHT_CANDLES_TZEIS$2 = flags.LIGHT_CANDLES_TZEIS;
const CHANUKAH_CANDLES$2 = flags.CHANUKAH_CANDLES;
// const MINOR_FAST = flags.MINOR_FAST;
const MAJOR_FAST$2 = flags.MAJOR_FAST;
const MINOR_HOLIDAY$2 = flags.MINOR_HOLIDAY;
const EREV$2 = flags.EREV;
const CHOL_HAMOED$1 = flags.CHOL_HAMOED;
const emojiPesach = '🫓';
const emojiSukkot = '🌿🍋';
const staticHolidays = [{
  mm: Tishrei,
  dd: 2,
  desc: 'Rosh Hashana II',
  flags: CHAG$1 | YOM_TOV_ENDS$1,
  emoji: '🍏🍯'
}, {
  mm: Tishrei,
  dd: 9,
  desc: 'Erev Yom Kippur',
  flags: EREV$2 | LIGHT_CANDLES$1
}, {
  mm: Tishrei,
  dd: 10,
  desc: 'Yom Kippur',
  flags: CHAG$1 | MAJOR_FAST$2 | YOM_TOV_ENDS$1
}, {
  mm: Tishrei,
  dd: 14,
  desc: 'Erev Sukkot',
  flags: CHUL_ONLY$1 | EREV$2 | LIGHT_CANDLES$1,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 15,
  desc: 'Sukkot I',
  flags: CHUL_ONLY$1 | CHAG$1 | LIGHT_CANDLES_TZEIS$2,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 16,
  desc: 'Sukkot II',
  flags: CHUL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 17,
  desc: 'Sukkot III (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 1,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 18,
  desc: 'Sukkot IV (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 2,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 19,
  desc: 'Sukkot V (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 3,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 20,
  desc: 'Sukkot VI (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 4,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 22,
  desc: 'Shmini Atzeret',
  flags: CHUL_ONLY$1 | CHAG$1 | LIGHT_CANDLES_TZEIS$2
}, {
  mm: Tishrei,
  dd: 23,
  desc: 'Simchat Torah',
  flags: CHUL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1
}, {
  mm: Tishrei,
  dd: 14,
  desc: 'Erev Sukkot',
  flags: IL_ONLY$1 | EREV$2 | LIGHT_CANDLES$1,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 15,
  desc: 'Sukkot I',
  flags: IL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 16,
  desc: 'Sukkot II (CH\'\'M)',
  flags: IL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 1,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 17,
  desc: 'Sukkot III (CH\'\'M)',
  flags: IL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 2,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 18,
  desc: 'Sukkot IV (CH\'\'M)',
  flags: IL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 3,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 19,
  desc: 'Sukkot V (CH\'\'M)',
  flags: IL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 4,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 20,
  desc: 'Sukkot VI (CH\'\'M)',
  flags: IL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 5,
  emoji: emojiSukkot
}, {
  mm: Tishrei,
  dd: 22,
  desc: 'Shmini Atzeret',
  flags: IL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1
}, {
  mm: Tishrei,
  dd: 21,
  desc: 'Sukkot VII (Hoshana Raba)',
  flags: LIGHT_CANDLES$1 | CHOL_HAMOED$1,
  chmDay: -1,
  emoji: emojiSukkot
}, {
  mm: Kislev,
  dd: 24,
  desc: 'Chanukah: 1 Candle',
  flags: EREV$2 | MINOR_HOLIDAY$2 | CHANUKAH_CANDLES$2,
  emoji: '🕎1️⃣'
}, {
  mm: Shvat,
  dd: 15,
  desc: 'Tu BiShvat',
  flags: MINOR_HOLIDAY$2,
  emoji: '🌳'
}, {
  mm: Adar2,
  dd: 13,
  desc: 'Erev Purim',
  flags: EREV$2 | MINOR_HOLIDAY$2,
  emoji: '🎭️📜'
}, {
  mm: Adar2,
  dd: 14,
  desc: 'Purim',
  flags: MINOR_HOLIDAY$2,
  emoji: '🎭️📜'
}, {
  mm: Adar2,
  dd: 15,
  desc: 'Shushan Purim',
  flags: MINOR_HOLIDAY$2,
  emoji: '🎭️📜'
},
// Pesach Israel
{
  mm: Nisan,
  dd: 14,
  desc: 'Erev Pesach',
  flags: IL_ONLY$1 | EREV$2 | LIGHT_CANDLES$1,
  emoji: '🫓🍷'
}, {
  mm: Nisan,
  dd: 15,
  desc: 'Pesach I',
  flags: IL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 16,
  desc: 'Pesach II (CH\'\'M)',
  flags: IL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 1,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 17,
  desc: 'Pesach III (CH\'\'M)',
  flags: IL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 2,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 18,
  desc: 'Pesach IV (CH\'\'M)',
  flags: IL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 3,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 19,
  desc: 'Pesach V (CH\'\'M)',
  flags: IL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 4,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 20,
  desc: 'Pesach VI (CH\'\'M)',
  flags: IL_ONLY$1 | CHOL_HAMOED$1 | LIGHT_CANDLES$1,
  chmDay: 5,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 21,
  desc: 'Pesach VII',
  flags: IL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: emojiPesach
},
// Pesach chutz l'aretz
{
  mm: Nisan,
  dd: 14,
  desc: 'Erev Pesach',
  flags: CHUL_ONLY$1 | EREV$2 | LIGHT_CANDLES$1,
  emoji: '🫓🍷'
}, {
  mm: Nisan,
  dd: 15,
  desc: 'Pesach I',
  flags: CHUL_ONLY$1 | CHAG$1 | LIGHT_CANDLES_TZEIS$2,
  emoji: '🫓🍷'
}, {
  mm: Nisan,
  dd: 16,
  desc: 'Pesach II',
  flags: CHUL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 17,
  desc: 'Pesach III (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 1,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 18,
  desc: 'Pesach IV (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 2,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 19,
  desc: 'Pesach V (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1,
  chmDay: 3,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 20,
  desc: 'Pesach VI (CH\'\'M)',
  flags: CHUL_ONLY$1 | CHOL_HAMOED$1 | LIGHT_CANDLES$1,
  chmDay: 4,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 21,
  desc: 'Pesach VII',
  flags: CHUL_ONLY$1 | CHAG$1 | LIGHT_CANDLES_TZEIS$2,
  emoji: emojiPesach
}, {
  mm: Nisan,
  dd: 22,
  desc: 'Pesach VIII',
  flags: CHUL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: emojiPesach
}, {
  mm: Iyyar,
  dd: 14,
  desc: 'Pesach Sheni',
  flags: MINOR_HOLIDAY$2
}, {
  mm: Iyyar,
  dd: 18,
  desc: 'Lag BaOmer',
  flags: MINOR_HOLIDAY$2,
  emoji: '🔥'
}, {
  mm: Sivan,
  dd: 5,
  desc: 'Erev Shavuot',
  flags: EREV$2 | LIGHT_CANDLES$1,
  emoji: '⛰️🌸'
}, {
  mm: Sivan,
  dd: 6,
  desc: 'Shavuot',
  flags: IL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: '⛰️🌸'
}, {
  mm: Sivan,
  dd: 6,
  desc: 'Shavuot I',
  flags: CHUL_ONLY$1 | CHAG$1 | LIGHT_CANDLES_TZEIS$2,
  emoji: '⛰️🌸'
}, {
  mm: Sivan,
  dd: 7,
  desc: 'Shavuot II',
  flags: CHUL_ONLY$1 | CHAG$1 | YOM_TOV_ENDS$1,
  emoji: '⛰️🌸'
}, {
  mm: Av,
  dd: 15,
  desc: 'Tu B\'Av',
  flags: MINOR_HOLIDAY$2,
  emoji: '❤️'
}, {
  mm: Elul,
  dd: 1,
  desc: 'Rosh Hashana LaBehemot',
  flags: MINOR_HOLIDAY$2,
  emoji: '🐑'
}, {
  mm: Elul,
  dd: 29,
  desc: 'Erev Rosh Hashana',
  flags: EREV$2 | LIGHT_CANDLES$1,
  emoji: '🍏🍯'
}];
const staticModernHolidays = [{
  firstYear: 5727,
  mm: Iyyar,
  dd: 28,
  desc: 'Yom Yerushalayim',
  chul: true
}, {
  firstYear: 5737,
  mm: Kislev,
  dd: 6,
  desc: 'Ben-Gurion Day',
  satPostponeToSun: true,
  friPostponeToSun: true
}, {
  firstYear: 5750,
  mm: Shvat,
  dd: 30,
  desc: 'Family Day'
}, {
  firstYear: 5758,
  mm: Cheshvan,
  dd: 12,
  desc: 'Yitzhak Rabin Memorial Day',
  friSatMovetoThu: true
}, {
  firstYear: 5764,
  mm: Iyyar,
  dd: 10,
  desc: 'Herzl Day',
  satPostponeToSun: true
}, {
  firstYear: 5765,
  mm: Tamuz,
  dd: 29,
  desc: 'Jabotinsky Day',
  satPostponeToSun: true
}, {
  firstYear: 5769,
  mm: Cheshvan,
  dd: 29,
  desc: 'Sigd',
  chul: true,
  suppressEmoji: true
}, {
  firstYear: 5777,
  mm: Nisan,
  dd: 10,
  desc: 'Yom HaAliyah',
  chul: true
}, {
  firstYear: 5777,
  mm: Cheshvan,
  dd: 7,
  desc: 'Yom HaAliyah School Observance'
}];

/*
    Hebcal - A Jewish Calendar Generator
    Copyright (c) 1994-2020 Danny Sadinoff
    Portions copyright Eyal Schachter and Michael J. Radwin

    https://github.com/hebcal/hebcal-es6

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/** Represents a built-in holiday like Pesach, Purim or Tu BiShvat */
class HolidayEvent extends Event {
  /**
   * Constructs Holiday event
   * @param {HDate} date Hebrew date event occurs
   * @param {string} desc Description (not translated)
   * @param {number} [mask=0] optional holiday flags
   * @param {Object} [attrs={}]
   */
  constructor(date, desc, mask, attrs) {
    super(date, desc, mask, attrs);
  }
  /** @return {string} */
  basename() {
    return this.getDesc().replace(/ \d{4}$/, '').replace(/ \(CH''M\)$/, '').replace(/ \(observed\)$/, '').replace(/ \(Hoshana Raba\)$/, '').replace(/ [IV]+$/, '').replace(/: \d Candles?$/, '').replace(/: 8th Day$/, '').replace(/^Erev /, '');
  }
  /** @return {string} */
  url() {
    const year = this.getDate().greg().getFullYear();
    if (year < 100) {
      return undefined;
    }
    const url = 'https://www.hebcal.com/holidays/' + this.basename().toLowerCase().replace(/'/g, '').replace(/ /g, '-') + '-' + this.urlDateSuffix();
    return this.getFlags() & flags.IL_ONLY ? url + '?i=on' : url;
  }
  /** @return {string} */
  urlDateSuffix() {
    const year = this.getDate().greg().getFullYear();
    return year;
  }
  /** @return {string} */
  getEmoji() {
    if (this.emoji) {
      return this.emoji;
    } else if (this.getFlags() & flags.SPECIAL_SHABBAT) {
      return '🕍';
    } else {
      return '✡️';
    }
  }
  /** @return {string[]} */
  getCategories() {
    if (this.cholHaMoedDay) {
      return ['holiday', 'major', 'cholhamoed'];
    }
    const cats = super.getCategories();
    if (cats[0] !== 'unknown') {
      return cats;
    }
    const desc = this.getDesc();
    // Don't depend on flags.MINOR_HOLIDAY always being set
    switch (desc) {
      case 'Lag BaOmer':
      case 'Leil Selichot':
      case 'Pesach Sheni':
      case 'Erev Purim':
      case 'Purim Katan':
      case 'Shushan Purim':
      case 'Tu B\'Av':
      case 'Tu BiShvat':
      case 'Rosh Hashana LaBehemot':
        return ['holiday', 'minor'];
      default:
        return ['holiday', 'major'];
    }
  }
}
const roshChodeshStr = 'Rosh Chodesh';

/** Represents Rosh Chodesh, the beginning of a new month */
class RoshChodeshEvent extends HolidayEvent {
  /**
   * Constructs Rosh Chodesh event
   * @param {HDate} date Hebrew date event occurs
   * @param {string} monthName Hebrew month name (not translated)
   */
  constructor(date, monthName) {
    super(date, `${roshChodeshStr} ${monthName}`, flags.ROSH_CHODESH);
  }
  /**
   * Returns (translated) description of this event
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    const monthName = this.getDesc().substring(roshChodeshStr.length + 1);
    return Locale.gettext(roshChodeshStr, locale) + ' ' + Locale.gettext(monthName, locale);
  }
  /** @return {string} */
  basename() {
    return this.getDesc();
  }
  /** @return {string} */
  getEmoji() {
    return this.emoji || '🌒';
  }
}

/**
 * Because Asara B'Tevet often occurs twice in the same Gregorian year,
 * we subclass HolidayEvent to override the `url()` method.
 */
class AsaraBTevetEvent extends HolidayEvent {
  /**
   * Constructs AsaraBTevetEvent
   * @param {HDate} date Hebrew date event occurs
   * @param {string} desc Description (not translated)
   * @param {number} [mask=0] optional holiday flags
   */
  constructor(date, desc, mask) {
    super(date, desc, mask);
  }
  /** @return {string} */
  urlDateSuffix() {
    const isoDateTime = this.getDate().greg().toISOString();
    const isoDate = isoDateTime.substring(0, isoDateTime.indexOf('T'));
    return isoDate.replace(/-/g, '');
  }
}
const mevarchimChodeshStr = 'Shabbat Mevarchim Chodesh';

/** Represents Mevarchim haChodesh, the announcement of the new month */
class MevarchimChodeshEvent extends Event {
  /**
   * Constructs Mevarchim haChodesh event
   * @param {HDate} date Hebrew date event occurs
   * @param {string} monthName Hebrew month name (not translated)
   */
  constructor(date, monthName) {
    super(date, `${mevarchimChodeshStr} ${monthName}`, flags.SHABBAT_MEVARCHIM);
    this.monthName = monthName;
    const hyear = date.getFullYear();
    const hmonth = date.getMonth();
    const monNext = hmonth == HDate.monthsInYear(hyear) ? months.NISAN : hmonth + 1;
    const molad = new MoladEvent(date, hyear, monNext);
    this.memo = molad.render('en');
  }
  /** @return {string} */
  basename() {
    return this.getDesc();
  }
  /**
   * Returns (translated) description of this event
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    return Locale.gettext(mevarchimChodeshStr, locale) + ' ' + Locale.gettext(this.monthName, locale);
  }
}

/** Represents Rosh Hashana, the Jewish New Year */
class RoshHashanaEvent extends HolidayEvent {
  /**
   * @private
   * @param {HDate} date Hebrew date event occurs
   * @param {number} hyear Hebrew year
   * @param {number} mask optional holiday flags
   */
  constructor(date, hyear, mask) {
    super(date, `Rosh Hashana ${hyear}`, mask);
    this.hyear = hyear;
  }
  /**
   * Returns (translated) description of this event
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    return Locale.gettext('Rosh Hashana', locale) + ' ' + this.hyear;
  }
  /** @return {string} */
  getEmoji() {
    return '🍏🍯';
  }
}
const ykk = 'Yom Kippur Katan';

/** YKK is minor day of atonement on the day preceeding each Rosh Chodesh */
class YomKippurKatanEvent extends HolidayEvent {
  /**
   * @private
   * @param {HDate} date Hebrew date event occurs
   * @param {string} nextMonthName name of the upcoming month
   */
  constructor(date, nextMonthName) {
    super(date, `${ykk} ${nextMonthName}`, flags.MINOR_FAST | flags.YOM_KIPPUR_KATAN);
    this.nextMonthName = nextMonthName;
    this.memo = `Minor Day of Atonement on the day preceeding Rosh Chodesh ${nextMonthName}`;
  }
  /** @return {string} */
  basename() {
    return this.getDesc();
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  render(locale) {
    return Locale.gettext(ykk, locale) + ' ' + Locale.gettext(this.nextMonthName, locale);
  }
  /**
   * @param {string} [locale] Optional locale name (defaults to active locale).
   * @return {string}
   */
  renderBrief(locale) {
    return Locale.gettext(ykk, locale);
  }
  /** @return {string} */
  url() {
    return undefined;
  }
}
const SUN = 0;
// const MON = 1;
const TUE = 2;
// const WED = 3;
const THU = 4;
const FRI$1 = 5;
const SAT$1 = 6;
const NISAN$2 = months.NISAN;
// const IYYAR = months.IYYAR;
// const SIVAN = months.SIVAN;
const TAMUZ = months.TAMUZ;
const AV = months.AV;
const ELUL$1 = months.ELUL;
const TISHREI$1 = months.TISHREI;
// const CHESHVAN = months.CHESHVAN;
const KISLEV$1 = months.KISLEV;
const TEVET$1 = months.TEVET;
// const SHVAT = months.SHVAT;
const ADAR_I$1 = months.ADAR_I;
// const ADAR_II = months.ADAR_II;

const CHAG = flags.CHAG;
// const LIGHT_CANDLES = flags.LIGHT_CANDLES;
// const YOM_TOV_ENDS = flags.YOM_TOV_ENDS;
// const CHUL_ONLY = flags.CHUL_ONLY;
// const IL_ONLY = flags.IL_ONLY;
const LIGHT_CANDLES_TZEIS$1 = flags.LIGHT_CANDLES_TZEIS;
const CHANUKAH_CANDLES$1 = flags.CHANUKAH_CANDLES;
const MINOR_FAST$1 = flags.MINOR_FAST;
const SPECIAL_SHABBAT$1 = flags.SPECIAL_SHABBAT;
const MODERN_HOLIDAY$1 = flags.MODERN_HOLIDAY;
const MAJOR_FAST$1 = flags.MAJOR_FAST;
const MINOR_HOLIDAY$1 = flags.MINOR_HOLIDAY;
const EREV$1 = flags.EREV;
// const CHOL_HAMOED = flags.CHOL_HAMOED;

/**
 * Avoid dependency on ES6 Map object
 * @private
 */
class SimpleMap {
  /**
   * @param {string} key
   * @return {boolean}
   */
  has(key) {
    return typeof this[key] !== 'undefined';
  }
  /**
   * @param {string} key
   * @return {any}
   */
  get(key) {
    return this[key];
  }
  /**
   * @param {string} key
   * @param {any} val
   */
  set(key, val) {
    this[key] = val;
  }
  /**
   * @return {string[]}
   */
  keys() {
    return Object.keys(this);
  }
}
const sedraCache = new SimpleMap();

/**
 * @private
 * @param {number} hyear
 * @param {boolean} il
 * @return {Sedra}
 */
function getSedra_(hyear, il) {
  const cacheKey = `${hyear}-${il ? 1 : 0}`;
  let sedra = sedraCache.get(cacheKey);
  if (!sedra) {
    sedra = new Sedra(hyear, il);
    sedraCache.set(cacheKey, sedra);
  }
  return sedra;
}
const emojiIsraelFlag = {
  emoji: '🇮🇱'
};
const chanukahEmoji = '🕎';
const yearCache = Object.create(null);
const KEYCAP_DIGITS = ['0️⃣', '1️⃣', '2️⃣', '3️⃣', '4️⃣', '5️⃣', '6️⃣', '7️⃣', '8️⃣', '9️⃣'];

/**
 * Lower-level holidays interface, which returns a `Map` of `Event`s indexed by
 * `HDate.toString()`. These events must filtered especially for `flags.IL_ONLY`
 * or `flags.CHUL_ONLY` depending on Israel vs. Diaspora holiday scheme.
 * @private
 * @param {number} year Hebrew year
 * @return {Map<string,Event[]>}
 */
function getHolidaysForYear_(year) {
  if (typeof year !== 'number') {
    throw new TypeError(`bad Hebrew year: ${year}`);
  } else if (year < 1 || year > 32658) {
    throw new RangeError(`Hebrew year ${year} out of range 1-32658`);
  }
  const cached = yearCache[year];
  if (cached) {
    return cached;
  }
  const RH = new HDate(1, TISHREI$1, year);
  const pesach = new HDate(15, NISAN$2, year);
  const h = new SimpleMap();
  // eslint-disable-next-line require-jsdoc
  function add(...events) {
    // for (const ev of events) {
    events.forEach(ev => {
      const key = ev.date.toString();
      const arr = h.get(key);
      if (typeof arr === 'object') {
        if (arr[0].getFlags() & flags.EREV) {
          arr.unshift(ev);
        } else {
          arr.push(ev);
        }
      } else {
        h.set(key, [ev]);
      }
    });
  }
  staticHolidays.forEach(h => {
    const hd = new HDate(h.dd, h.mm, year);
    const ev = new HolidayEvent(hd, h.desc, h.flags);
    if (h.emoji) ev.emoji = h.emoji;
    if (h.chmDay) ev.cholHaMoedDay = h.chmDay;
    add(ev);
  });

  // standard holidays that don't shift based on year
  add(new RoshHashanaEvent(RH, year, CHAG | LIGHT_CANDLES_TZEIS$1));

  // Variable date holidays
  add(new HolidayEvent(new HDate(3 + (RH.getDay() == THU), TISHREI$1, year), 'Tzom Gedaliah', MINOR_FAST$1));
  // first SAT after RH
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, 7 + RH.abs())), 'Shabbat Shuva', SPECIAL_SHABBAT$1));
  const rchTevet = HDate.shortKislev(year) ? new HDate(1, TEVET$1, year) : new HDate(30, KISLEV$1, year);
  add(new HolidayEvent(rchTevet, 'Chag HaBanot', MINOR_HOLIDAY$1));
  // yes, we know Kislev 30-32 are wrong
  // HDate() corrects the month automatically
  for (let candles = 2; candles <= 8; candles++) {
    const hd = new HDate(23 + candles, KISLEV$1, year);
    add(new HolidayEvent(hd, `Chanukah: ${candles} Candles`, MINOR_HOLIDAY$1 | CHANUKAH_CANDLES$1, {
      chanukahDay: candles - 1,
      emoji: chanukahEmoji + KEYCAP_DIGITS[candles]
    }));
  }
  add(new HolidayEvent(new HDate(32, KISLEV$1, year), 'Chanukah: 8th Day', MINOR_HOLIDAY$1, {
    chanukahDay: 8,
    emoji: chanukahEmoji
  }));
  add(new AsaraBTevetEvent(new HDate(10, TEVET$1, year), 'Asara B\'Tevet', MINOR_FAST$1));
  const pesachAbs = pesach.abs();
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, pesachAbs - 43)), 'Shabbat Shekalim', SPECIAL_SHABBAT$1), new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, pesachAbs - 30)), 'Shabbat Zachor', SPECIAL_SHABBAT$1), new HolidayEvent(new HDate(pesachAbs - (pesach.getDay() == TUE ? 33 : 31)), 'Ta\'anit Esther', MINOR_FAST$1));
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, pesachAbs - 14) - 7), 'Shabbat Parah', SPECIAL_SHABBAT$1), new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, pesachAbs - 14)), 'Shabbat HaChodesh', SPECIAL_SHABBAT$1), new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, pesachAbs - 1)), 'Shabbat HaGadol', SPECIAL_SHABBAT$1), new HolidayEvent(
  // if the fast falls on Shabbat, move to Thursday
  pesach.prev().getDay() == SAT$1 ? pesach.onOrBefore(THU) : new HDate(14, NISAN$2, year), 'Ta\'anit Bechorot', MINOR_FAST$1));
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, new HDate(1, TISHREI$1, year + 1).abs() - 4)), 'Leil Selichot', MINOR_HOLIDAY$1, {
    emoji: '🕍'
  }));
  if (pesach.getDay() == SUN) {
    add(new HolidayEvent(new HDate(16, months.ADAR_II, year), 'Purim Meshulash', MINOR_HOLIDAY$1));
  }
  if (HDate.isLeapYear(year)) {
    add(new HolidayEvent(new HDate(14, ADAR_I$1, year), 'Purim Katan', MINOR_HOLIDAY$1, {
      emoji: '🎭️'
    }));
    add(new HolidayEvent(new HDate(15, ADAR_I$1, year), 'Shushan Purim Katan', MINOR_HOLIDAY$1, {
      emoji: '🎭️'
    }));
  }
  const nisan27dt = dateYomHaShoah(year);
  if (nisan27dt) {
    add(new HolidayEvent(nisan27dt, 'Yom HaShoah', MODERN_HOLIDAY$1));
  }
  const yomHaZikaronDt = dateYomHaZikaron(year);
  if (yomHaZikaronDt) {
    add(new HolidayEvent(yomHaZikaronDt, 'Yom HaZikaron', MODERN_HOLIDAY$1, emojiIsraelFlag), new HolidayEvent(yomHaZikaronDt.next(), 'Yom HaAtzma\'ut', MODERN_HOLIDAY$1, emojiIsraelFlag));
  }
  staticModernHolidays.forEach(h => {
    if (year >= h.firstYear) {
      let hd = new HDate(h.dd, h.mm, year);
      const dow = hd.getDay();
      if (h.friSatMovetoThu && (dow === FRI$1 || dow === SAT$1)) {
        hd = hd.onOrBefore(THU);
      } else if (h.friPostponeToSun && dow === FRI$1) {
        hd = new HDate(hd.abs() + 2);
      } else if (h.satPostponeToSun && dow === SAT$1) {
        hd = hd.next();
      }
      const mask = h.chul ? MODERN_HOLIDAY$1 : MODERN_HOLIDAY$1 | flags.IL_ONLY;
      const ev = new HolidayEvent(hd, h.desc, mask);
      if (!h.suppressEmoji) {
        ev.emoji = '🇮🇱';
      }
      add(ev);
    }
  });
  let tamuz17 = new HDate(17, TAMUZ, year);
  let tamuz17attrs;
  if (tamuz17.getDay() == SAT$1) {
    tamuz17 = new HDate(18, TAMUZ, year);
    tamuz17attrs = {
      observed: true
    };
  }
  add(new HolidayEvent(tamuz17, 'Tzom Tammuz', MINOR_FAST$1, tamuz17attrs));
  let av9dt = new HDate(9, AV, year);
  let av9title = 'Tish\'a B\'Av';
  let av9attrs;
  if (av9dt.getDay() == SAT$1) {
    av9dt = av9dt.next();
    av9attrs = {
      observed: true
    };
    av9title += ' (observed)';
  }
  const av9abs = av9dt.abs();
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, av9abs)), 'Shabbat Chazon', SPECIAL_SHABBAT$1), new HolidayEvent(av9dt.prev(), 'Erev Tish\'a B\'Av', EREV$1 | MAJOR_FAST$1, av9attrs), new HolidayEvent(av9dt, av9title, MAJOR_FAST$1, av9attrs), new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT$1, av9abs + 7)), 'Shabbat Nachamu', SPECIAL_SHABBAT$1));
  const monthsInYear = HDate.monthsInYear(year);
  for (let month = 1; month <= monthsInYear; month++) {
    const monthName = HDate.getMonthName(month, year);
    if ((month == NISAN$2 ? HDate.daysInMonth(HDate.monthsInYear(year - 1), year - 1) : HDate.daysInMonth(month - 1, year)) == 30) {
      add(new RoshChodeshEvent(new HDate(1, month, year), monthName));
      add(new RoshChodeshEvent(new HDate(30, month - 1, year), monthName));
    } else if (month !== TISHREI$1) {
      add(new RoshChodeshEvent(new HDate(1, month, year), monthName));
    }
    if (month == ELUL$1) {
      continue;
    }

    // Don't worry about month overrun; will get "Nisan" for month=14
    const nextMonthName = HDate.getMonthName(month + 1, year);
    add(new MevarchimChodeshEvent(new HDate(29, month, year).onOrBefore(SAT$1), nextMonthName));
  }

  // Begin: Yom Kippur Katan
  // start at Iyyar because one may not fast during Nisan
  for (let month = months.IYYAR; month <= monthsInYear; month++) {
    const nextMonth = month + 1;
    // Yom Kippur Katan is not observed on the day before Rosh Hashanah.
    // Not observed prior to Rosh Chodesh Cheshvan because Yom Kippur has just passed.
    // Not observed before Rosh Chodesh Tevet, because that day is Hanukkah.
    if (nextMonth === months.TISHREI || nextMonth === months.CHESHVAN || nextMonth === months.TEVET) {
      continue;
    }
    let ykk = new HDate(29, month, year);
    const dow = ykk.getDay();
    if (dow === FRI$1 || dow === SAT$1) {
      ykk = ykk.onOrBefore(THU);
    }
    const nextMonthName = HDate.getMonthName(nextMonth, year);
    const ev = new YomKippurKatanEvent(ykk, nextMonthName);
    add(ev);
  }
  const sedra = getSedra_(year, false);
  const beshalachHd = sedra.find(15);
  add(new HolidayEvent(beshalachHd, 'Shabbat Shirah', SPECIAL_SHABBAT$1));

  // Birkat Hachamah appears only once every 28 years
  const birkatHaChama = getBirkatHaChama(year);
  if (birkatHaChama) {
    const hd = new HDate(birkatHaChama);
    add(new HolidayEvent(hd, 'Birkat Hachamah', MINOR_HOLIDAY$1, {
      emoji: '☀️'
    }));
  }
  yearCache[year] = h;
  return h;
}

/**
 * Birkat Hachamah appears only once every 28 years.
 * Although almost always in Nisan, it can occur in Adar II.
 *   - 27 Adar II 5461 (Gregorian year 1701)
 *   - 29 Adar II 5993 (Gregorian year 2233)
 *
 * Due to drift, this will eventually slip into Iyyar
 *   - 2 Iyyar 7141 (Gregorian year 3381)
 * @private
 * @param {number} year
 * @return {number}
 */
function getBirkatHaChama(year) {
  const leap = HDate.isLeapYear(year);
  const startMonth = leap ? months.ADAR_II : NISAN$2;
  const startDay = leap ? 20 : 1;
  const baseRd = HDate.hebrew2abs(year, startMonth, startDay);
  for (let day = 0; day <= 40; day++) {
    const abs = baseRd + day;
    const elapsed = abs + 1373429;
    if (elapsed % 10227 == 172) {
      return abs;
    }
  }
  return 0;
}

/** @private */
const cals = Object.create(null);

/**
 * Plug-ins for daily learning calendars such as Daf Yomi, Mishna Yomi, Nach Yomi, etc.
 *
 * Learning schedules are provided by the `@hebcal/learning` package.
 */
class DailyLearning {
  /**
   * Register a new learning calendar.
   * @param {string} name
   * @param {Function} calendar
   */
  static addCalendar(name, calendar) {
    if (typeof calendar !== 'function') {
      throw new TypeError(`Invalid calendar function: ${calendar}`);
    }
    cals[name] = calendar;
  }

  /**
   * Returns an event from daily calendar for a given date. Returns `null` if there
   * is no learning from this calendar on this date.
   * @param {string} name
   * @param {HDate} hd
   * @return {Event}
   */
  static lookup(name, hd) {
    const lookup = cals[name];
    if (typeof lookup === 'function') {
      return lookup(hd);
    }
    return null;
  }
}

const NISAN$1 = months.NISAN;
const CHESHVAN = months.CHESHVAN;
const KISLEV = months.KISLEV;
const TEVET = months.TEVET;
const SHVAT = months.SHVAT;
const ADAR_I = months.ADAR_I;
const ADAR_II = months.ADAR_II;

/**
 * @private
 * @param {number} hyear Hebrew year
 * @param {Date|HDate} gdate Gregorian or Hebrew date of death
 * @return {HDate} anniversary occurring in hyear
 */
function getYahrzeit_(hyear, gdate) {
  const orig = HDate.isHDate(gdate) ? gdate : new HDate(gdate);
  let hDeath = {
    yy: orig.getFullYear(),
    mm: orig.getMonth(),
    dd: orig.getDate()
  };
  if (hyear <= hDeath.yy) {
    // `Hebrew year ${hyear} occurs on or before original date in ${hDeath.yy}`
    return undefined;
  }
  if (hDeath.mm == CHESHVAN && hDeath.dd == 30 && !longCheshvan(hDeath.yy + 1)) {
    // If it's Heshvan 30 it depends on the first anniversary;
    // if that was not Heshvan 30, use the day before Kislev 1.
    hDeath = abs2hebrew(hebrew2abs(hyear, KISLEV, 1) - 1);
  } else if (hDeath.mm == KISLEV && hDeath.dd == 30 && shortKislev(hDeath.yy + 1)) {
    // If it's Kislev 30 it depends on the first anniversary;
    // if that was not Kislev 30, use the day before Teveth 1.
    hDeath = abs2hebrew(hebrew2abs(hyear, TEVET, 1) - 1);
  } else if (hDeath.mm == ADAR_II) {
    // If it's Adar II, use the same day in last month of year (Adar or Adar II).
    hDeath.mm = monthsInYear(hyear);
  } else if (hDeath.mm == ADAR_I && hDeath.dd == 30 && !isLeapYear(hyear)) {
    // If it's the 30th in Adar I and year is not a leap year
    // (so Adar has only 29 days), use the last day in Shevat.
    hDeath.dd = 30;
    hDeath.mm = SHVAT;
  }
  // In all other cases, use the normal anniversary of the date of death.

  // advance day to rosh chodesh if needed
  if (hDeath.mm == CHESHVAN && hDeath.dd == 30 && !longCheshvan(hyear)) {
    hDeath.mm = KISLEV;
    hDeath.dd = 1;
  } else if (hDeath.mm == KISLEV && hDeath.dd == 30 && shortKislev(hyear)) {
    hDeath.mm = TEVET;
    hDeath.dd = 1;
  }
  return new HDate(hDeath.dd, hDeath.mm, hyear);
}

/**
 * @private
 * @param {number} hyear Hebrew year
 * @param {Date|HDate} gdate Gregorian or Hebrew date of event
 * @return {HDate} anniversary occurring in `hyear`
 */
function getBirthdayOrAnniversary_(hyear, gdate) {
  const orig = HDate.isHDate(gdate) ? gdate : new HDate(gdate);
  const origYear = orig.getFullYear();
  if (hyear === origYear) {
    return orig;
  } else if (hyear < origYear) {
    // `Hebrew year ${hyear} occurs on or before original date in ${origYear}`
    return undefined;
  }
  const isOrigLeap = isLeapYear(origYear);
  let month = orig.getMonth();
  let day = orig.getDate();
  if (month == ADAR_I && !isOrigLeap || month == ADAR_II && isOrigLeap) {
    month = monthsInYear(hyear);
  } else if (month == CHESHVAN && day == 30 && !longCheshvan(hyear)) {
    month = KISLEV;
    day = 1;
  } else if (month == KISLEV && day == 30 && shortKislev(hyear)) {
    month = TEVET;
    day = 1;
  } else if (month == ADAR_I && day == 30 && isOrigLeap && !isLeapYear(hyear)) {
    month = NISAN$1;
    day = 1;
  }
  return new HDate(day, month, hyear);
}

var version="4.1.1";

var headers$1={"plural-forms":"nplurals=2; plural=(n > 1);"};var contexts$1={"":{Shabbat:["Shabbos"],"Achrei Mot":["Achrei Mos"],Bechukotai:["Bechukosai"],"Beha'alotcha":["Beha'aloscha"],Bereshit:["Bereshis"],Chukat:["Chukas"],"Erev Shavuot":["Erev Shavuos"],"Erev Sukkot":["Erev Sukkos"],"Ki Tavo":["Ki Savo"],"Ki Teitzei":["Ki Seitzei"],"Ki Tisa":["Ki Sisa"],Matot:["Matos"],"Purim Katan":["Purim Koton"],Tazria:["Sazria"],"Shabbat Chazon":["Shabbos Chazon"],"Shabbat HaChodesh":["Shabbos HaChodesh"],"Shabbat HaGadol":["Shabbos HaGadol"],"Shabbat Nachamu":["Shabbos Nachamu"],"Shabbat Parah":["Shabbos Parah"],"Shabbat Shekalim":["Shabbos Shekalim"],"Shabbat Shuva":["Shabbos Shuvah"],"Shabbat Zachor":["Shabbos Zachor"],Shavuot:["Shavuos"],"Shavuot I":["Shavuos I"],"Shavuot II":["Shavuos II"],Shemot:["Shemos"],"Shmini Atzeret":["Shmini Atzeres"],"Simchat Torah":["Simchas Torah"],Sukkot:["Sukkos"],"Sukkot I":["Sukkos I"],"Sukkot II":["Sukkos II"],"Sukkot II (CH''M)":["Sukkos II (CH''M)"],"Sukkot III (CH''M)":["Sukkos III (CH''M)"],"Sukkot IV (CH''M)":["Sukkos IV (CH''M)"],"Sukkot V (CH''M)":["Sukkos V (CH''M)"],"Sukkot VI (CH''M)":["Sukkos VI (CH''M)"],"Sukkot VII (Hoshana Raba)":["Sukkos VII (Hoshana Raba)"],"Ta'anit Bechorot":["Ta'anis Bechoros"],"Ta'anit Esther":["Ta'anis Esther"],Toldot:["Toldos"],Vaetchanan:["Vaeschanan"],Yitro:["Yisro"],"Vezot Haberakhah":["Vezos Haberakhah"],Parashat:["Parshas"],"Leil Selichot":["Leil Selichos"],"Shabbat Mevarchim Chodesh":["Shabbos Mevorchim Chodesh"],"Shabbat Shirah":["Shabbos Shirah"],Tevet:["Teves"],"Asara B'Tevet":["Asara B'Teves"],"Alot HaShachar":["Alos HaShachar"],"Kriat Shema, sof zeman":["Krias Shema, sof zman"],"Tefilah, sof zeman":["Tefilah, sof zman"],"Kriat Shema, sof zeman (MGA)":["Krias Shema, sof zman (MGA)"],"Tefilah, sof zeman (MGA)":["Tefilah, sof zman (MGA)"],"Chatzot HaLailah":["Chatzos HaLailah"],"Chatzot hayom":["Chatzos"],"Tzeit HaKochavim":["Tzeis HaKochavim"],"Birkat Hachamah":["Birkas Hachamah"],"Shushan Purim Katan":["Shushan Purim Koton"]}};var poAshkenazi = {headers:headers$1,contexts:contexts$1};

Locale.addLocale('ashkenazi', poAshkenazi);
Locale.addLocale('a', poAshkenazi);

var headers={"plural-forms":"nplurals=2; plural=(n > 1);"};var contexts={"":{Shabbat:["שַׁבָּת"],"Daf Yomi":["דַף יוֹמִי"],Parashat:["פָּרָשַׁת"],"Achrei Mot":["אַחֲרֵי מוֹת"],Balak:["בָּלָק"],Bamidbar:["בְּמִדְבַּר"],Bechukotai:["בְּחֻקֹּתַי"],"Beha'alotcha":["בְּהַעֲלֹתְךָ"],Behar:["בְּהַר"],Bereshit:["בְּרֵאשִׁית"],Beshalach:["בְּשַׁלַּח"],Bo:["בֹּא"],"Chayei Sara":["חַיֵּי שָֹרָה"],Chukat:["חֻקַּת"],Devarim:["דְּבָרִים"],Eikev:["עֵקֶב"],Emor:["אֱמוֹר"],"Ha'Azinu":["הַאֲזִינוּ"],Kedoshim:["קְדשִׁים"],"Ki Tavo":["כִּי־תָבוֹא"],"Ki Teitzei":["כִּי־תֵצֵא"],"Ki Tisa":["כִּי תִשָּׂא"],Korach:["קוֹרַח"],"Lech-Lecha":["לֶךְ־לְךָ"],Masei:["מַסְעֵי"],Matot:["מַּטּוֹת"],Metzora:["מְּצֹרָע"],Miketz:["מִקֵּץ"],Mishpatim:["מִּשְׁפָּטִים"],Nasso:["נָשׂא"],Nitzavim:["נִצָּבִים"],Noach:["נֹחַ"],Pekudei:["פְקוּדֵי"],Pinchas:["פִּינְחָס"],"Re'eh":["רְאֵה"],"Sh'lach":["שְׁלַח־לְךָ"],Shemot:["שְׁמוֹת"],Shmini:["שְּׁמִינִי"],Shoftim:["שׁוֹפְטִים"],Tazria:["תַזְרִיעַ"],Terumah:["תְּרוּמָה"],Tetzaveh:["תְּצַוֶּה"],Toldot:["תּוֹלְדוֹת"],Tzav:["צַו"],Vaera:["וָאֵרָא"],Vaetchanan:["וָאֶתְחַנַּן"],Vayakhel:["וַיַּקְהֵל"],Vayechi:["וַיְחִי"],Vayeilech:["וַיֵּלֶךְ"],Vayera:["וַיֵּרָא"],Vayeshev:["וַיֵּשֶׁב"],Vayetzei:["וַיֵּצֵא"],Vayigash:["וַיִּגַּשׁ"],Vayikra:["וַיִּקְרָא"],Vayishlach:["וַיִּשְׁלַח"],"Vezot Haberakhah":["וְזֹאת הַבְּרָכָה"],Yitro:["יִתְרוֹ"],"Asara B'Tevet":["עֲשָׂרָה בְּטֵבֵת"],"Candle lighting":["הַדלָקָת נֵרוֹת"],Chanukah:["חֲנוּכָּה"],"Chanukah: 1 Candle":["חֲנוּכָּה: א׳ נֵר"],"Chanukah: 2 Candles":["חֲנוּכָּה: ב׳ נֵרוֹת"],"Chanukah: 3 Candles":["חֲנוּכָּה: ג׳ נֵרוֹת"],"Chanukah: 4 Candles":["חֲנוּכָּה: ד׳ נֵרוֹת"],"Chanukah: 5 Candles":["חֲנוּכָּה: ה׳ נֵרוֹת"],"Chanukah: 6 Candles":["חֲנוּכָּה: ו׳ נֵרוֹת"],"Chanukah: 7 Candles":["חֲנוּכָּה: ז׳ נֵרוֹת"],"Chanukah: 8 Candles":["חֲנוּכָּה: ח׳ נֵרוֹת"],"Chanukah: 8th Day":["חֲנוּכָּה: יוֹם ח׳"],"Days of the Omer":["סְפִירַת הָעוֹמֶר"],Omer:["עוֹמֶר"],"day of the Omer":["בָּעוֹמֶר"],"Erev Pesach":["עֶרֶב פֶּסַח"],"Erev Purim":["עֶרֶב פּוּרִים"],"Erev Rosh Hashana":["עֶרֶב רֹאשׁ הַשָּׁנָה"],"Erev Shavuot":["עֶרֶב שָׁבוּעוֹת"],"Erev Simchat Torah":["עֶרֶב שִׂמְחַת תּוֹרָה"],"Erev Sukkot":["עֶרֶב סוּכּוֹת"],"Erev Tish'a B'Av":["עֶרֶב תִּשְׁעָה בְּאָב"],"Erev Yom Kippur":["עֶרֶב יוֹם כִּפּוּר"],Havdalah:["הַבדָלָה"],"Lag BaOmer":["ל״ג בָּעוֹמֶר"],"Leil Selichot":["סליחות"],Pesach:["פֶּסַח"],"Pesach I":["פֶּסַח א׳"],"Pesach II":["פֶּסַח ב׳"],"Pesach II (CH''M)":["פֶּסַח ב׳ (חוה״מ)"],"Pesach III (CH''M)":["פֶּסַח ג׳ (חוה״מ)"],"Pesach IV (CH''M)":["פֶּסַח ד׳ (חוה״מ)"],"Pesach Sheni":["פֶּסַח שני"],"Pesach V (CH''M)":["פֶּסַח ה׳ (חוה״מ)"],"Pesach VI (CH''M)":["פֶּסַח ו׳ (חוה״מ)"],"Pesach VII":["פֶּסַח ז׳"],"Pesach VIII":["פֶּסַח ח׳"],Purim:["פּוּרִים"],"Purim Katan":["פּוּרִים קָטָן"],"Rosh Chodesh %s":["רֹאשׁ חוֹדֶשׁ %s"],"Rosh Chodesh":["רֹאשׁ חוֹדֶשׁ"],Adar:["אַדָר"],"Adar I":["אַדָר א׳"],"Adar II":["אַדָר ב׳"],Av:["אָב"],Cheshvan:["חֶשְׁוָן"],Elul:["אֱלוּל"],Iyyar:["אִיָיר"],Kislev:["כִּסְלֵו"],Nisan:["נִיסָן"],"Sh'vat":["שְׁבָט"],Sivan:["סִיוָן"],Tamuz:["תַּמּוּז"],Tevet:["טֵבֵת"],Tishrei:["תִשְׁרֵי"],"Rosh Hashana":["רֹאשׁ הַשָּׁנָה"],"Rosh Hashana I":["רֹאשׁ הַשָּׁנָה א׳"],"Rosh Hashana II":["רֹאשׁ הַשָּׁנָה ב׳"],"Shabbat Chazon":["שַׁבָּת חֲזוֹן"],"Shabbat HaChodesh":["שַׁבָּת הַחֹדֶשׁ"],"Shabbat HaGadol":["שַׁבָּת הַגָּדוֹל"],"Shabbat Machar Chodesh":["שַׁבָּת מָחָר חוֹדֶשׁ"],"Shabbat Nachamu":["שַׁבָּת נַחֲמוּ"],"Shabbat Parah":["שַׁבָּת פּרה"],"Shabbat Rosh Chodesh":["שַׁבָּת רֹאשׁ חוֹדֶשׁ"],"Shabbat Shekalim":["שַׁבָּת שְׁקָלִים"],"Shabbat Shuva":["שַׁבָּת שׁוּבָה"],"Shabbat Zachor":["שַׁבָּת זָכוֹר"],Shavuot:["שָׁבוּעוֹת"],"Shavuot I":["שָׁבוּעוֹת א׳"],"Shavuot II":["שָׁבוּעוֹת ב׳"],"Shmini Atzeret":["שְׁמִינִי עֲצֶרֶת"],"Shushan Purim":["שׁוּשָׁן פּוּרִים"],Sigd:["סיגד"],"Simchat Torah":["שִׂמְחַת תּוֹרָה"],Sukkot:["סוּכּוֹת"],"Sukkot I":["סוּכּוֹת א׳"],"Sukkot II":["סוּכּוֹת ב׳"],"Sukkot II (CH''M)":["סוּכּוֹת ב׳ (חוה״מ)"],"Sukkot III (CH''M)":["סוּכּוֹת ג׳ (חוה״מ)"],"Sukkot IV (CH''M)":["סוּכּוֹת ד׳ (חוה״מ)"],"Sukkot V (CH''M)":["סוּכּוֹת ה׳ (חוה״מ)"],"Sukkot VI (CH''M)":["סוּכּוֹת ו׳ (חוה״מ)"],"Sukkot VII (Hoshana Raba)":["סוּכּוֹת ז׳ (הוֹשַׁעְנָא רַבָּה)"],"Ta'anit Bechorot":["תַּעֲנִית בְּכוֹרוֹת"],"Ta'anit Esther":["תַּעֲנִית אֶסְתֵּר"],"Tish'a B'Av":["תִּשְׁעָה בְּאָב"],"Tu B'Av":["טוּ בְּאָב"],"Tu BiShvat":["טוּ בִּשְׁבָט"],"Tu B'Shvat":["טוּ בִּשְׁבָט"],"Tzom Gedaliah":["צוֹם גְּדַלְיָה"],"Tzom Tammuz":["צוֹם תָּמוּז"],"Yom HaAtzma'ut":["יוֹם הָעַצְמָאוּת"],"Yom HaShoah":["יוֹם הַשּׁוֹאָה"],"Yom HaZikaron":["יוֹם הַזִּכָּרוֹן"],"Yom Kippur":["יוֹם כִּפּוּר"],"Yom Yerushalayim":["יוֹם יְרוּשָׁלַיִם"],"Yom HaAliyah":["יוֹם הַעֲלִיָּה"],"Yom HaAliyah School Observance":["שְׁמִירָת בֵּית הַסֵפֶר לְיוֹם הַעֲלִיָּה"],"Pesach I (on Shabbat)":["פֶּסַח יוֹם א׳ (בְּשַׁבָּת)"],"Pesach Chol ha-Moed Day 1":["פֶּסַח חוֹל הַמּוֹעֵד יוֹם א׳"],"Pesach Chol ha-Moed Day 2":["פֶּסַח חוֹל הַמּוֹעֵד יוֹם ב׳"],"Pesach Chol ha-Moed Day 3":["פֶּסַח חוֹל הַמּוֹעֵד יוֹם ג׳"],"Pesach Chol ha-Moed Day 4":["פֶּסַח חוֹל הַמּוֹעֵד יוֹם ד׳"],"Pesach Chol ha-Moed Day 5":["פֶּסַח חוֹל הַמּוֹעֵד יוֹם ה׳"],"Pesach Shabbat Chol ha-Moed":["פֶּסַח שַׁבָּת חוֹל הַמּוֹעֵד"],"Shavuot II (on Shabbat)":["שָׁבוּעוֹת יוֹם ב׳ (בְּשַׁבָּת)"],"Rosh Hashana I (on Shabbat)":["רֹאשׁ הַשָּׁנָה יוֹם א׳ (בְּשַׁבָּת)"],"Yom Kippur (on Shabbat)":["יוֹם כִּפּוּר (בְּשַׁבָּת)"],"Yom Kippur (Mincha, Traditional)":["יוֹם כִּפּוּר מִנחָה"],"Yom Kippur (Mincha, Alternate)":["יוֹם כִּפּוּר מִנחָה"],"Sukkot I (on Shabbat)":["סוּכּוֹת יוֹם א׳ (בְּשַׁבָּת)"],"Sukkot Chol ha-Moed Day 1":["סוּכּוֹת חוֹל הַמּוֹעֵד יוֹם א׳"],"Sukkot Chol ha-Moed Day 2":["סוּכּוֹת חוֹל הַמּוֹעֵד יוֹם ב׳"],"Sukkot Chol ha-Moed Day 3":["סוּכּוֹת חוֹל הַמּוֹעֵד יוֹם ג׳"],"Sukkot Chol ha-Moed Day 4":["סוּכּוֹת חוֹל הַמּוֹעֵד יוֹם ד׳"],"Sukkot Chol ha-Moed Day 5":["סוּכּוֹת חוֹל הַמּוֹעֵד יוֹם ה׳"],"Sukkot Shabbat Chol ha-Moed":["סוּכּוֹת שַׁבָּת חוֹל הַמּוֹעֵד"],"Sukkot Final Day (Hoshana Raba)":["סוּכּוֹת ז׳ (הוֹשַׁעְנָא רַבָּה)"],"Rosh Chodesh Adar":["רֹאשׁ חוֹדֶשׁ אַדָר"],"Rosh Chodesh Adar I":["רֹאשׁ חוֹדֶשׁ אַדָר א׳"],"Rosh Chodesh Adar II":["רֹאשׁ חוֹדֶשׁ אַדָר ב׳"],"Rosh Chodesh Av":["רֹאשׁ חוֹדֶשׁ אָב"],"Rosh Chodesh Cheshvan":["רֹאשׁ חוֹדֶשׁ חֶשְׁוָן"],"Rosh Chodesh Elul":["רֹאשׁ חוֹדֶשׁ אֱלוּל"],"Rosh Chodesh Iyyar":["רֹאשׁ חוֹדֶשׁ אִיָיר"],"Rosh Chodesh Kislev":["רֹאשׁ חוֹדֶשׁ כִּסְלֵו"],"Rosh Chodesh Nisan":["רֹאשׁ חוֹדֶשׁ נִיסָן"],"Rosh Chodesh Sh'vat":["רֹאשׁ חוֹדֶשׁ שְׁבָט"],"Rosh Chodesh Sivan":["רֹאשׁ חוֹדֶשׁ סִיוָן"],"Rosh Chodesh Tamuz":["רֹאשׁ חוֹדֶשׁ תָּמוּז"],"Rosh Chodesh Tevet":["רֹאשׁ חוֹדֶשׁ טֵבֵת"],min:["דקות"],"Fast begins":["תחילת הַצוֹם"],"Fast ends":["סִיּוּם הַצוֹם"],"Rosh Hashana LaBehemot":["רֹאשׁ הַשָּׁנָה לְמַעְשַׂר בְּהֵמָה"],"Tish'a B'Av (observed)":["תִּשְׁעָה בְּאָב נִדחֶה"],"Shabbat Mevarchim Chodesh":["שַׁבָּת מְבָרְכִים חוֹדֶשׁ"],"Shabbat Shirah":["שַׁבָּת שִׁירָה"],"Chatzot HaLailah":["חֲצוֹת הַלַיְלָה"],"Alot haShachar":["עֲלוֹת הַשַּׁחַר"],Misheyakir:["מִשֶּׁיַּכִּיר"],"Misheyakir Machmir":["מִשֶּׁיַּכִּיר מַחמִיר"],Dawn:["דִּימְדּוּמֵי בּוֹקֵר"],Sunrise:["הַנֵץ הַחַמָּה"],"Kriat Shema, sof zeman":["סוֹף זְמַן קְרִיאַת שְׁמַע גר״א"],"Tefilah, sof zeman":["סוֹף זְמַן תְּפִלָּה גר״א"],"Kriat Shema, sof zeman (MGA)":["סוֹף זְמַן קְרִיאַת שְׁמַע מג״א"],"Tefilah, sof zeman (MGA)":["סוֹף זְמַן תְּפִלָּה מג״א"],"Chatzot hayom":["חֲצוֹת הַיּוֹם"],"Mincha Gedolah":["מִנְחָה גְּדוֹלָה"],"Mincha Ketanah":["מִנְחָה קְטַנָּה"],"Plag HaMincha":["פְּלַג הַמִּנְחָה"],Dusk:["דִּימְדּוּמֵי עֶרֶב"],Sunset:["שְׁקִיעָה"],"Nightfall - End of ordained fasts":["לַיְלָה - גמר תעניות דרבנן"],"Tzeit HaKochavim":["צֵאת כוכבים"],Lovingkindness:["חֶֽסֶד"],Might:["גְבוּרָה"],Beauty:["תִּפאֶרֶת"],Eternity:["נֶּֽצַח"],Splendor:["הוֹד"],Foundation:["יְּסוֹד"],Majesty:["מַּלְכוּת"],day:["יוֹם"],"Chanukah Day 1":["חֲנוּכָּה יוֹם א׳"],"Chanukah Day 2":["חֲנוּכָּה יוֹם ב׳"],"Chanukah Day 3":["חֲנוּכָּה יוֹם ג׳"],"Chanukah Day 4":["חֲנוּכָּה יוֹם ד׳"],"Chanukah Day 5":["חֲנוּכָּה יוֹם ה׳"],"Chanukah Day 6":["חֲנוּכָּה יוֹם ו׳"],"Chanukah Day 7":["חֲנוּכָּה יוֹם ז׳"],"Chanukah Day 7 (on Rosh Chodesh)":["חֲנוּכָּה יוֹם ז׳ (רֹאשׁ חוֹדֶשׁ)"],"Chanukah Day 8":["חֲנוּכָּה יוֹם ח׳"],"Chanukah Day 1 (on Shabbat)":["חֲנוּכָּה יוֹם א׳ (בְּשַׁבָּת)"],"Chanukah Day 2 (on Shabbat)":["חֲנוּכָּה יוֹם ב׳ (בְּשַׁבָּת)"],"Chanukah Day 3 (on Shabbat)":["חֲנוּכָּה יוֹם ג׳ (בְּשַׁבָּת)"],"Chanukah Day 4 (on Shabbat)":["חֲנוּכָּה יוֹם ד׳ (בְּשַׁבָּת)"],"Chanukah Day 5 (on Shabbat)":["חֲנוּכָּה יוֹם ה׳ (בְּשַׁבָּת)"],"Chanukah Day 7 (on Shabbat)":["חֲנוּכָּה יוֹם ז׳ (בְּשַׁבָּת)"],"Chanukah Day 8 (on Shabbat)":["חֲנוּכָּה יוֹם ח׳ (בְּשַׁבָּת)"],"Shabbat Rosh Chodesh Chanukah":["שַׁבָּת רֹאשׁ חוֹדֶשׁ חֲנוּכָּה"],"Yom Kippur Katan":["יוֹם כִּפּוּר קָטָן"],"Family Day":["יוֹם הַמִּשׁפָּחָה"],"Yitzhak Rabin Memorial Day":["יוֹם הַזִּכָּרוֹן ליצחק רבין"],"Jabotinsky Day":["יוֹם ז׳בוטינסקי"],"Herzl Day":["יוֹם הרצל"],"Ben-Gurion Day":["יוֹם בן־גוריון"],"Birkat Hachamah":["בִרְכַּת הַחַמָּה"],"Shushan Purim Katan":["שׁוּשָׁן פּוּרִים קָטָן"],"Purim Meshulash":["פּוּרִים מְשׁוּלָּשׁ"],"after sunset":["אחרי השקיעה"],Yerushalmi:["יְרוּשַׁלְמִי"],"Chag HaBanot":["חַג הַבָּנוֹת"],Joshua:["יְהוֹשׁוּעַ"],Judges:["שׁוֹפְטִים"],"I Samuel":["שְׁמוּאֵל רִאשׁוֹן"],"II Samuel":["שְׁמוּאֵל שֵׁנִי"],"I Kings":["מְלָכִים רִאשׁוֹן"],"II Kings":["מְלָכִים שֵׁנִי"],Isaiah:["יְשַׁעְיָהוּ"],Jeremiah:["יִרְמְיָהוּ"],Ezekiel:["יְחֶזְקֵאל"],Hosea:["הוֹשֵׁעַ"],Joel:["יוֹאֵל"],Amos:["עָמוּס"],Obadiah:["עוֹבַדְיָה"],Jonah:["יוֹנָה"],Micah:["מִיכָה"],Nachum:["נַחוּם"],Habakkuk:["חֲבַקּוּק"],Zephaniah:["צְפַנְיָה"],Haggai:["חַגַּי"],Zechariah:["זְכַרְיָה"],Malachi:["מַלְאָכִי"],Psalms:["תְּהִלִּים"],Proverbs:["מִשְׁלֵי"],Job:["אִיּוֹב"],"Song of Songs":["שִׁיר הַשִּׁירִים"],Ruth:["רוּת"],Lamentations:["אֵיכָה"],Ecclesiastes:["קֹהֶלֶת"],Esther:["אֶסְתֵּר"],Daniel:["דָּנִיֵּאל"],Ezra:["עֶזְרָא"],Nehemiah:["נְחֶמְיָה"],"I Chronicles":["דִברֵי הַיָמִים רִאשׁוֹן"],"II Chronicles":["דִברֵי הַיָמִים שֵׁנִי"],"Yom Kippur (Mincha)":["יוֹם כִּפּוּר מִנחָה"],"Tish'a B'Av (Mincha)":["תִּשְׁעָה בְּאָב מִנחָה"],"Asara B'Tevet (Mincha)":["עֲשָׂרָה בְּטֵבֵת מִנחָה"],"Ta'anit Bechorot (Mincha)":["תַּעֲנִית בְּכוֹרוֹת מִנחָה"],"Ta'anit Esther (Mincha)":["תַּעֲנִית אֶסְתֵּר מִנחָה"],"Tzom Gedaliah (Mincha)":["צוֹם גְּדַלְיָה מִנחָה"],"Tzom Tammuz (Mincha)":["צוֹם תָּמוּז מִנחָה"]}};var poHe = {headers:headers,contexts:contexts};

Locale.addLocale('he', poHe);
Locale.addLocale('h', poHe);
const heStrs = poHe.contexts[''];
const heNoNikud = {};
Object.keys(heStrs).forEach(key => {
  heNoNikud[key] = [Locale.hebrewStripNikkud(heStrs[key][0])];
});
const poHeNoNikud = {
  headers: poHe.headers,
  contexts: {
    '': heNoNikud
  }
};
Locale.addLocale('he-x-NoNikud', poHeNoNikud);

const NONE$1 = 0;
const HALF = 1;
const WHOLE = 2;

/**
 * @private
 * @param {Event[]} events
 * @param {HDate} hdate
 * @return {number}
 */
function hallel_(events, hdate) {
  const whole = events.filter(ev => {
    /** @type {string} */
    const desc = ev.getDesc();
    /** @type {HDate} */
    const hd = ev.getDate();
    const month = hd.getMonth();
    const mday = hd.getDate();
    return desc.startsWith('Chanukah') || desc.startsWith('Shavuot') || desc.startsWith('Sukkot') || month === months.NISAN && (mday === 15 || mday === 16) && ev.getFlags() & flags.CHAG ||
    // Pesach
    desc === 'Yom HaAtzma\'ut' || desc === 'Yom Yerushalayim';
  }).map(ev => {
    return ev.getDate().abs();
  });
  const abs = hdate.abs();
  if (whole.includes(abs)) {
    return WHOLE;
  }
  const half = events.filter(ev => {
    const desc = ev.getDesc();
    return ev.getFlags() & flags.ROSH_CHODESH || desc.startsWith('Pesach') && desc !== 'Pesach I' && desc !== 'Pesach II';
  }).map(ev => {
    return ev.getDate().abs();
  });
  if (half.includes(abs)) {
    return HALF;
  }
  return NONE$1;
}

/**
 * @private
 * @param {number} start
 * @param {number} end
 * @return {number[]}
 */
function range(start, end) {
  const arr = [];
  for (let i = start; i <= end; i++) {
    arr.push(i);
  }
  return arr;
}
const cache = Object.create(null);
const NONE = {
  shacharit: false,
  mincha: false,
  allCongs: false
};

/**
 * @private
 * @param {HDate} hdate
 * @param {boolean} il
 * @return {TachanunResult}
 */
function tachanun_(hdate, il) {
  return tachanun0(hdate, il, true);
}

/**
 * @private
 * @param {HDate} hdate
 * @param {boolean} il
 * @param {boolean} checkNext
 * @return {TachanunResult}
 */
function tachanun0(hdate, il, checkNext) {
  const year = hdate.getFullYear();
  const key = `${year}-${il ? 1 : 0}`;
  const dates = cache[key] = cache[key] || tachanunYear(year, il);
  const abs = hdate.abs();
  if (dates.none.indexOf(abs) > -1) {
    return NONE;
  }
  const dow = hdate.getDay();
  const ret = {
    shacharit: false,
    mincha: false,
    allCongs: false
  };
  if (dates.some.indexOf(abs) === -1) {
    ret.allCongs = true;
  }
  if (dow !== 6) {
    ret.shacharit = true;
  }
  const tomorrow = abs + 1;
  if (checkNext && dates.yesPrev.indexOf(tomorrow) === -1) {
    const tmp = tachanun0(new HDate(tomorrow), il, false);
    ret.mincha = tmp.shacharit;
  } else {
    ret.mincha = dow !== 5;
  }
  if (ret.allCongs && !ret.mincha && !ret.shacharit) {
    return NONE;
  }
  return ret;
}

/**
 * @private
 * @param {number} year
 * @param {boolean} il
 * @return {*}
 */
function tachanunYear(year, il) {
  const leap = HDate.isLeapYear(year);
  const monthsInYear = 12 + leap;
  let av9dt = new HDate(9, months.AV, year);
  if (av9dt.getDay() === 6) {
    av9dt = av9dt.next();
  }
  let shushPurim = new HDate(15, months.ADAR_II, year);
  if (shushPurim.getDay() === 6) {
    shushPurim = shushPurim.next();
  }
  const none = [].concat(
  // Rosh Chodesh - 1st of every month. Also includes RH day 1 (1 Tishrei)
  range(1, monthsInYear).map(month => new HDate(1, month, year)),
  // Rosh Chodesh - 30th of months that have one
  range(1, monthsInYear).filter(month => HDate.daysInMonth(month, year) === 30).map(month => new HDate(30, month, year)), new HDate(2, months.TISHREI, year),
  // Rosh Hashana II
  // entire month of Nisan
  range(1, HDate.daysInMonth(months.NISAN, year)).map(mday => new HDate(mday, months.NISAN, year)), new HDate(18, months.IYYAR, year),
  // Lag BaOmer
  // Rosh Chodesh Sivan thru Isru Chag
  range(1, 8 - (il ? 1 : 0)).map(mday => new HDate(mday, months.SIVAN, year)), av9dt,
  // Tisha B'Av
  new HDate(15, months.AV, year),
  // Tu B'Av
  new HDate(29, months.ELUL, year),
  // Erev Rosh Hashanah
  // Erev Yom Kippur thru Isru Chag
  range(9, 24 - (il ? 1 : 0)).map(mday => new HDate(mday, months.TISHREI, year)),
  // Chanukah
  range(25, 33).map(mday => new HDate(mday, months.KISLEV, year)), new HDate(15, months.SHVAT, year),
  // Tu BiShvat
  new HDate(14, months.ADAR_II, year),
  // Purim
  shushPurim, leap ? new HDate(14, months.ADAR_I, year) : [] // Purim Katan
  );

  const some = [].concat(
  // Until 14 Sivan
  range(1, 13).map(mday => new HDate(mday, months.SIVAN, year)),
  // Until after Rosh Chodesh Cheshvan
  range(20, 31).map(mday => new HDate(mday, months.TISHREI, year)), new HDate(14, months.IYYAR, year),
  // Pesach Sheini
  // Yom HaAtzma'ut, which changes based on day of week
  year >= 5708 ? dateYomHaZikaron(year).next() : [],
  // Yom Yerushalayim
  year >= 5727 ? new HDate(28, months.IYYAR, year) : []);
  const yesPrev = [].concat(new HDate(29, months.ELUL, year - 1),
  // Erev Rosh Hashanah
  new HDate(9, months.TISHREI, year),
  // Erev Yom Kippur
  new HDate(14, months.IYYAR, year) // Pesach Sheini
  );

  return {
    none: none.map(hd => hd.abs()).sort(),
    some: some.map(hd => hd.abs()).sort(),
    yesPrev: yesPrev.map(hd => hd.abs()).sort()
  };
}

/*
    Hebcal - A Jewish Calendar Generator
    Copyright (c) 1994-2020 Danny Sadinoff
    Portions copyright Eyal Schachter and Michael J. Radwin

    https://github.com/hebcal/hebcal-es6

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
const FRI = 5;
const SAT = 6;
const NISAN = months.NISAN;
// const IYYAR = months.IYYAR;
const SIVAN = months.SIVAN;
// const TAMUZ = months.TAMUZ;
// const AV = months.AV;
const ELUL = months.ELUL;
const TISHREI = months.TISHREI;
const LIGHT_CANDLES = flags.LIGHT_CANDLES;
const YOM_TOV_ENDS = flags.YOM_TOV_ENDS;
const CHUL_ONLY = flags.CHUL_ONLY;
const IL_ONLY = flags.IL_ONLY;
const LIGHT_CANDLES_TZEIS = flags.LIGHT_CANDLES_TZEIS;
const CHANUKAH_CANDLES = flags.CHANUKAH_CANDLES;
const MINOR_FAST = flags.MINOR_FAST;
const SPECIAL_SHABBAT = flags.SPECIAL_SHABBAT;
const MODERN_HOLIDAY = flags.MODERN_HOLIDAY;
const MAJOR_FAST = flags.MAJOR_FAST;
const ROSH_CHODESH = flags.ROSH_CHODESH;
const PARSHA_HASHAVUA = flags.PARSHA_HASHAVUA;
const DAF_YOMI = flags.DAF_YOMI;
const OMER_COUNT = flags.OMER_COUNT;
const SHABBAT_MEVARCHIM = flags.SHABBAT_MEVARCHIM;
const MINOR_HOLIDAY = flags.MINOR_HOLIDAY;
const EREV = flags.EREV;
const CHOL_HAMOED = flags.CHOL_HAMOED;
const unrecognizedAlreadyWarned = Object.create(null);
const RECOGNIZED_OPTIONS = {
  location: 1,
  year: 1,
  isHebrewYear: 1,
  month: 1,
  numYears: 1,
  start: 1,
  end: 1,
  candlelighting: 1,
  candleLightingMins: 1,
  havdalahMins: 1,
  havdalahDeg: 1,
  sedrot: 1,
  il: 1,
  noMinorFast: 1,
  noModern: 1,
  shabbatMevarchim: 1,
  noRoshChodesh: 1,
  noSpecialShabbat: 1,
  noHolidays: 1,
  omer: 1,
  molad: 1,
  ashkenazi: 1,
  locale: 1,
  addHebrewDates: 1,
  addHebrewDatesForEvents: 1,
  appendHebrewToSubject: 1,
  mask: 1,
  userMask: 1,
  yomKippurKatan: 1,
  hour12: 1,
  dailyLearning: 1
};

/**
 * @private
 * @param {CalOptions} options
 */
function warnUnrecognizedOptions(options) {
  Object.keys(options).forEach(k => {
    if (typeof RECOGNIZED_OPTIONS[k] === 'undefined' && !unrecognizedAlreadyWarned[k]) {
      console.warn(`Ignoring unrecognized HebrewCalendar option: ${k}`);
      unrecognizedAlreadyWarned[k] = true;
    }
  });
}

/**
 * A bit like Object.assign(), but just a shallow copy
 * @private
 * @param {any} target
 * @param {any} source
 * @return {any}
 */
function shallowCopy(target, source) {
  Object.keys(source).forEach(k => target[k] = source[k]);
  return target;
}
const israelCityOffset = {
  'Jerusalem': 40,
  'Haifa': 30,
  'Zikhron Ya\'aqov': 30,
  'Zikhron Ya\'akov': 30,
  'Zikhron Yaakov': 30,
  'Zichron Ya\'akov': 30,
  'Zichron Yaakov': 30
};
const geoIdCandleOffset = {
  '281184': 40,
  // Jerusalem
  '294801': 30,
  // Haifa
  '293067': 30 // Zikhron Yaakov
};

/**
 * Modifies options in-place
 * @private
 * @param {CalOptions} options
 */
function checkCandleOptions(options) {
  if (!options.candlelighting) {
    return;
  }
  const location = options.location;
  if (typeof location === 'undefined' || !location instanceof Location) {
    throw new TypeError('options.candlelighting requires valid options.location');
  }
  if (typeof options.havdalahMins === 'number' && typeof options.havdalahDeg === 'number') {
    throw new TypeError('options.havdalahMins and options.havdalahDeg are mutually exclusive');
  }
  let min = parseInt(options.candleLightingMins, 10) || 18;
  if (location.getIsrael() && Math.abs(min) === 18) {
    const geoid = location.getGeoId();
    const offset0 = geoIdCandleOffset[geoid];
    if (typeof offset0 === 'number') {
      min = offset0;
    }
    const offset = israelCityOffset[location.getShortName()];
    if (typeof offset === 'number') {
      min = offset;
    }
  }
  options.candleLightingMins = -1 * Math.abs(min);
  if (typeof options.havdalahMins === 'number') {
    options.havdalahMins = Math.abs(options.havdalahMins);
  } else if (typeof options.havdalahDeg === 'number') {
    options.havdalahDeg = Math.abs(options.havdalahDeg);
  } else {
    options.havdalahDeg = 8.5;
  }
}

/**
 * Options to configure which events are returned
 * @typedef {Object} CalOptions
 * @property {Location} location - latitude/longitude/tzid used for candle-lighting
 * @property {number} year - Gregorian or Hebrew year
 * @property {boolean} isHebrewYear - to interpret year as Hebrew year
 * @property {number} month - Gregorian or Hebrew month (to filter results to a single month)
 * @property {number} numYears - generate calendar for multiple years (default 1)
 * @property {Date|HDate|number} start - use specific start date (requires end date)
 * @property {Date|HDate|number} end - use specific end date (requires start date)
 * @property {boolean} candlelighting - calculate candle-lighting and havdalah times
 * @property {number} candleLightingMins - minutes before sundown to light candles (default 18)
 * @property {number} havdalahMins - minutes after sundown for Havdalah (typical values are 42, 50, or 72).
 *      If `undefined` (the default), calculate Havdalah according to Tzeit Hakochavim -
 *      Nightfall (the point when 3 small stars are observable in the night time sky with
 *      the naked eye). If `0`, Havdalah times are supressed.
 * @property {number} havdalahDeg - degrees for solar depression for Havdalah.
 *      Default is 8.5 degrees for 3 small stars. use 7.083 degress for 3 medium-sized stars.
 *      If `0`, Havdalah times are supressed.
 * @property {boolean} sedrot - calculate parashah hashavua on Saturdays
 * @property {boolean} il - Israeli holiday and sedra schedule
 * @property {boolean} noMinorFast - suppress minor fasts
 * @property {boolean} noModern - suppress modern holidays
 * @property {boolean} noRoshChodesh - suppress Rosh Chodesh
 * @property {boolean} shabbatMevarchim - add Shabbat Mevarchim
 * @property {boolean} noSpecialShabbat - suppress Special Shabbat
 * @property {boolean} noHolidays - suppress regular holidays
 * @property {boolean} omer - include Days of the Omer
 * @property {boolean} molad - include event announcing the molad
 * @property {boolean} ashkenazi - use Ashkenazi transliterations for event titles (default Sephardi transliterations)
 * @property {string} locale - translate event titles according to a locale
 *      Default value is `en`, also built-in are `he` and `ashkenazi`.
 *      Additional locales (such as `ru` or `fr`) are provided by the
 *      {@link https://github.com/hebcal/hebcal-locales @hebcal/locales} package
 * @property {boolean} addHebrewDates - print the Hebrew date for the entire date range
 * @property {boolean} addHebrewDatesForEvents - print the Hebrew date for dates with some events
 * @property {number} mask - use bitmask from `flags` to filter events
 * @property {boolean} yomKippurKatan - include Yom Kippur Katan (default `false`).
 *      יוֹם כִּפּוּר קָטָן is a minor day of atonement occurring monthly on the day preceeding each Rosh Chodesh.
 *      Yom Kippur Katan is omitted in Elul (on the day before Rosh Hashanah),
 *      Tishrei (Yom Kippur has just passed), Kislev (due to Chanukah)
 *      and Nisan (fasting not permitted during Nisan).
 *      When Rosh Chodesh occurs on Shabbat or Sunday, Yom Kippur Katan is observed on the preceding Thursday.
 *      See {@link https://en.wikipedia.org/wiki/Yom_Kippur_Katan#Practices Wikipedia Yom Kippur Katan practices}
 * @property {boolean} hour12 - Whether to use 12-hour time (as opposed to 24-hour time).
 *      Possible values are `true` and `false`; the default is locale dependent.
 * @property {Object<string,any>} dailyLearning - map of options to enable daily study calendars
 *      such as `dafYomi`, `mishnaYomi`, `nachYomi` with value `true`. For `yerushalmi`
 *      the value should be a `number` for edition (`1` for Vilna, `2` for Schottenstein).
 */

/**
 * @typedef {Object} TachanunResult
 * @property {boolean} shacharit Tachanun is said at Shacharit
 * @property {boolean} mincha Tachanun is said at Mincha
 * @property {boolean} allCongs All congregations say Tachanun on the day
 */

/**
 * Gets the R.D. days for a number, Date, or HDate
 * @private
 * @param {Date|HDate|number} d
 * @return {number}
 */
function getAbs(d) {
  if (typeof d == 'number') return d;
  if (isDate(d)) return greg2abs(d);
  if (HDate.isHDate(d)) return d.abs();
  throw new TypeError(`Invalid date type: ${d}`);
}

/**
 * Parse options object to determine start & end days
 * @private
 * @param {CalOptions} options
 * @return {number[]}
 */
function getStartAndEnd(options) {
  if (options.start && !options.end || options.end && !options.start) {
    throw new TypeError('Both options.start and options.end are required');
  } else if (options.start && options.end) {
    return [getAbs(options.start), getAbs(options.end)];
  }
  const isHebrewYear = Boolean(options.isHebrewYear);
  const theYear = typeof options.year !== 'undefined' ? parseInt(options.year, 10) : isHebrewYear ? new HDate().getFullYear() : new Date().getFullYear();
  if (isNaN(theYear)) {
    throw new RangeError(`Invalid year ${options.year}`);
  } else if (isHebrewYear && theYear < 1) {
    throw new RangeError(`Invalid Hebrew year ${theYear}`);
  }
  let theMonth = NaN;
  if (options.month) {
    if (isHebrewYear) {
      theMonth = HDate.monthNum(options.month);
    } else {
      theMonth = options.month;
    }
  }
  const numYears = parseInt(options.numYears, 10) || 1;
  if (isHebrewYear) {
    const startDate = new HDate(1, theMonth || TISHREI, theYear);
    let startAbs = startDate.abs();
    const endAbs = options.month ? startAbs + startDate.daysInMonth() : new HDate(1, TISHREI, theYear + numYears).abs() - 1;
    // for full Hebrew year, start on Erev Rosh Hashana which
    // is technically in the previous Hebrew year
    // (but conveniently lets us get candle-lighting time for Erev)
    if (!theMonth && theYear > 1) {
      startAbs--;
    }
    return [startAbs, endAbs];
  } else {
    const gregMonth = options.month ? theMonth - 1 : 0;
    const startGreg = new Date(theYear, gregMonth, 1);
    if (theYear < 100) {
      startGreg.setFullYear(theYear);
    }
    const startAbs = greg2abs(startGreg);
    let endAbs;
    if (options.month) {
      endAbs = startAbs + daysInMonth$1(theMonth, theYear) - 1;
    } else {
      const endYear = theYear + numYears;
      const endGreg = new Date(endYear, 0, 1);
      if (endYear < 100) {
        endGreg.setFullYear(endYear);
      }
      endAbs = greg2abs(endGreg) - 1;
    }
    return [startAbs, endAbs];
  }
}

/**
 * Mask to filter Holiday array
 * @private
 * @param {CalOptions} options
 * @return {number}
 */
function getMaskFromOptions(options) {
  if (typeof options.mask === 'number') {
    const m = options.mask;
    if (m & ROSH_CHODESH) delete options.noRoshChodesh;
    if (m & MODERN_HOLIDAY) delete options.noModern;
    if (m & MINOR_FAST) delete options.noMinorFast;
    if (m & SPECIAL_SHABBAT) delete options.noSpecialShabbat;
    if (m & PARSHA_HASHAVUA) options.sedrot = true;
    if (m & DAF_YOMI) {
      options.dailyLearning = options.dailyLearning || {};
      options.dailyLearning.dafYomi = true;
    }
    if (m & OMER_COUNT) options.omer = true;
    if (m & SHABBAT_MEVARCHIM) options.shabbatMevarchim = true;
    if (m & flags.MISHNA_YOMI) {
      options.dailyLearning = options.dailyLearning || {};
      options.dailyLearning.mishnaYomi = true;
    }
    if (m & flags.NACH_YOMI) {
      options.dailyLearning = options.dailyLearning || {};
      options.dailyLearning.nachYomi = true;
    }
    if (m & flags.YOM_KIPPUR_KATAN) options.yomKippurKatan = true;
    if (m & flags.YERUSHALMI_YOMI) {
      options.dailyLearning = options.dailyLearning || {};
      options.dailyLearning.yerushalmi = 1;
    }
    options.userMask = true;
    return m;
  }
  const il = options.il || options.location && options.location.il || false;
  let mask = 0;

  // default options
  if (!options.noHolidays) {
    mask |= ROSH_CHODESH | YOM_TOV_ENDS | MINOR_FAST | SPECIAL_SHABBAT | MODERN_HOLIDAY | MAJOR_FAST | MINOR_HOLIDAY | EREV | CHOL_HAMOED | LIGHT_CANDLES | LIGHT_CANDLES_TZEIS | CHANUKAH_CANDLES;
  }
  if (options.candlelighting) {
    mask |= LIGHT_CANDLES | LIGHT_CANDLES_TZEIS | YOM_TOV_ENDS;
  }
  // suppression of defaults
  if (options.noRoshChodesh) {
    mask &= ~ROSH_CHODESH;
  }
  if (options.noModern) {
    mask &= ~MODERN_HOLIDAY;
  }
  if (options.noMinorFast) {
    mask &= ~MINOR_FAST;
  }
  if (options.noSpecialShabbat) {
    mask &= ~SPECIAL_SHABBAT;
    mask &= ~SHABBAT_MEVARCHIM;
  }
  if (il) {
    mask |= IL_ONLY;
  } else {
    mask |= CHUL_ONLY;
  }
  // non-default options
  if (options.sedrot) {
    mask |= PARSHA_HASHAVUA;
  }
  if (options.omer) {
    mask |= OMER_COUNT;
  }
  if (options.shabbatMevarchim) {
    mask |= SHABBAT_MEVARCHIM;
  }
  if (options.yomKippurKatan) {
    mask |= flags.YOM_KIPPUR_KATAN;
  }
  if (options.dailyLearning) {
    const dailyLearning = options.dailyLearning;
    if (dailyLearning.dafYomi) {
      mask |= DAF_YOMI;
    }
    if (dailyLearning.mishnaYomi) {
      mask |= flags.MISHNA_YOMI;
    }
    if (dailyLearning.nachYomi) {
      mask |= flags.NACH_YOMI;
    }
    if (dailyLearning.yerushalmi) {
      mask |= flags.YERUSHALMI_YOMI;
    }
  }
  return mask;
}
const MASK_LIGHT_CANDLES = LIGHT_CANDLES | LIGHT_CANDLES_TZEIS | CHANUKAH_CANDLES | YOM_TOV_ENDS;
const defaultLocation = new Location(0, 0, false, 'UTC');
const hour12cc = {
  US: 1,
  CA: 1,
  BR: 1,
  AU: 1,
  NZ: 1,
  DO: 1,
  PR: 1,
  GR: 1,
  IN: 1,
  KR: 1,
  NP: 1,
  ZA: 1
};

/**
 * @private
 * @param {Event} ev
 * @return {boolean}
 */
function observedInIsrael(ev) {
  return ev.observedInIsrael();
}

/**
 * @private
 * @param {Event} ev
 * @return {boolean}
 */
function observedInDiaspora(ev) {
  return ev.observedInDiaspora();
}
const yearArrayCache = Object.create(null);

/**
 * HebrewCalendar is the main interface to the `@hebcal/core` library.
 * This namespace is used to calculate holidays, rosh chodesh, candle lighting & havdalah times,
 * Parashat HaShavua, Daf Yomi, days of the omer, and the molad.
 * Event names can be rendered in several languges using the `locale` option.
 */
class HebrewCalendar {
  /**
   * Calculates holidays and other Hebrew calendar events based on {@link CalOptions}.
   *
   * Each holiday is represented by an {@link Event} object which includes a date,
   * a description, flags and optional attributes.
   * If given no options, returns holidays for the Diaspora for the current Gregorian year.
   *
   * The date range returned by this function can be controlled by:
   * * `options.year` - Gregorian (e.g. 1993) or Hebrew year (e.g. 5749)
   * * `options.isHebrewYear` - to interpret `year` as Hebrew year
   * * `options.numYears` - generate calendar for multiple years (default 1)
   * * `options.month` - Gregorian or Hebrew month (to filter results to a single month)
   *
   * Alternatively, specify start and end days with `Date` or {@link HDate} instances:
   * * `options.start` - use specific start date (requires `end` date)
   * * `options.end` - use specific end date (requires `start` date)
   *
   * Unless `options.noHolidays == true`, default holidays include:
   * * Major holidays - Rosh Hashana, Yom Kippur, Pesach, Sukkot, etc.
   * * Minor holidays - Purim, Chanukah, Tu BiShvat, Lag BaOmer, etc.
   * * Minor fasts - Ta'anit Esther, Tzom Gedaliah, etc. (unless `options.noMinorFast`)
   * * Special Shabbatot - Shabbat Shekalim, Zachor, etc. (unless `options.noSpecialShabbat`)
   * * Modern Holidays - Yom HaShoah, Yom HaAtzma'ut, etc. (unless `options.noModern`)
   * * Rosh Chodesh (unless `options.noRoshChodesh`)
   *
   * Holiday and Torah reading schedules differ between Israel and the Disapora.
   * Set `options.il=true` to use the Israeli schedule.
   *
   * Additional non-default event types can be specified:
   * * Parashat HaShavua - weekly Torah Reading on Saturdays (`options.sedrot`)
   * * Counting of the Omer (`options.omer`)
   * * Shabbat Mevarchim HaChodesh on Saturday before Rosh Chodesh (`options.shabbatMevarchim`)
   * * Molad announcement on Saturday before Rosh Chodesh (`options.molad`)
   * * Yom Kippur Katan (`options.yomKippurKatan`)
   *
   * Daily Study of texts:
   * * Babylonian Talmud Daf Yomi (`options.dailyLearning.dafYomi`)
   * * Jerusalem Talmud (Yerushalmi) Yomi (`options.dailyLearning.yerushalmi`)
   * * Mishna Yomi (`options.dailyLearning.mishnaYomi`)
   * * Nach Yomi (`options.dailyLearning.nachYomi`)
   *
   * Candle-lighting and Havdalah times are approximated using latitude and longitude
   * specified by the {@link Location} class. The `Location` class contains a small
   * database of cities with their associated geographic information and time-zone information.
   * If you ever have any doubts about Hebcal's times, consult your local halachic authority.
   * If you enter geographic coordinates above the arctic circle or antarctic circle,
   * the times are guaranteed to be wrong.
   *
   * To add candle-lighting options, set `options.candlelighting=true` and set
   * `options.location` to an instance of `Location`. By default, candle lighting
   * time is 18 minutes before sundown (40 minutes for Jerusalem,
   * 30 minutes for Haifa and Zikhron Ya'akov) and Havdalah is
   * calculated according to Tzeit Hakochavim - Nightfall (the point when 3 small stars
   * are observable in the night time sky with the naked eye). The default Havdalah
   * option (Tzeit Hakochavim) is calculated when the sun is 8.5° below the horizon.
   * These defaults can be changed using these options:
   * * `options.candleLightingMins` - minutes before sundown to light candles
   * * `options.havdalahMins` - minutes after sundown for Havdalah (typical values are 42, 50, or 72).
   *    Havdalah times are supressed when `options.havdalahMins=0`.
   * * `options.havdalahDeg` - degrees for solar depression for Havdalah.
   *    Default is 8.5 degrees for 3 small stars. Use 7.083 degress for 3 medium-sized stars.
   *    Havdalah times are supressed when `options.havdalahDeg=0`.
   *
   * If both `options.candlelighting=true` and `options.location` is specified,
   * Chanukah candle-lighting times and minor fast start/end times will also be generated.
   * Chanukah candle-lighting is at dusk (when the sun is 6.0° below the horizon in the evening)
   * on weekdays, at regular candle-lighting time on Fridays, and at regular Havdalah time on
   * Saturday night (see above).
   *
   * Minor fasts begin at Alot HaShachar (sun is 16.1° below the horizon in the morning) and
   * end when 3 medium-sized stars are observable in the night sky (sun is 7.083° below the horizon
   * in the evening).
   *
   * Two options also exist for generating an Event with the Hebrew date:
   * * `options.addHebrewDates` - print the Hebrew date for the entire date range
   * * `options.addHebrewDatesForEvents` - print the Hebrew date for dates with some events
   *
   * Lastly, translation and transliteration of event titles is controlled by
   * `options.locale` and the {@link Locale} API.
   * `@hebcal/core` supports three locales by default:
   * * `en` - default, Sephardic transliterations (e.g. "Shabbat")
   * * `ashkenazi` - Ashkenazi transliterations (e.g. "Shabbos")
   * * `he` - Hebrew (e.g. "שַׁבָּת")
   *
   * Additional locales (such as `ru` or `fr`) are supported by the
   * {@link https://github.com/hebcal/hebcal-locales @hebcal/locales} package
   *
   * @example
   * import {HebrewCalendar, HDate, Location, Event} from '@hebcal/core';
   * const options = {
   *   year: 1981,
   *   isHebrewYear: false,
   *   candlelighting: true,
   *   location: Location.lookup('San Francisco'),
   *   sedrot: true,
   *   omer: true,
   * };
   * const events = HebrewCalendar.calendar(options);
   * for (const ev of events) {
   *   const hd = ev.getDate();
   *   const date = hd.greg();
   *   console.log(date.toLocaleDateString(), ev.render('en'), hd.toString());
   * }
   * @param {CalOptions} [options={}]
   * @return {Event[]}
   */
  static calendar(options = {}) {
    options = shallowCopy({}, options); // so we can modify freely
    checkCandleOptions(options);
    const location = options.location = options.location || defaultLocation;
    const il = options.il = options.il || location.il || false;
    options.mask = getMaskFromOptions(options);
    if (options.ashkenazi || options.locale) {
      if (options.locale && typeof options.locale !== 'string') {
        throw new TypeError(`Invalid options.locale: ${options.locale}`);
      }
      const locale = options.ashkenazi ? 'ashkenazi' : options.locale;
      const translationObj = Locale.useLocale(locale);
      if (!translationObj) {
        throw new TypeError(`Locale '${locale}' not found; did you forget to import @hebcal/locales?`);
      }
    } else {
      Locale.useLocale('en');
    }
    const evts = [];
    let sedra;
    let holidaysYear;
    let beginOmer;
    let endOmer;
    let currentYear = -1;
    const startAndEnd = getStartAndEnd(options);
    warnUnrecognizedOptions(options);
    const startAbs = startAndEnd[0];
    const endAbs = startAndEnd[1];
    const startGreg = abs2greg(startAbs);
    if (startGreg.getFullYear() < 100) {
      options.candlelighting = false;
    }
    for (let abs = startAbs; abs <= endAbs; abs++) {
      const hd = new HDate(abs);
      const hyear = hd.getFullYear();
      if (hyear != currentYear) {
        currentYear = hyear;
        holidaysYear = getHolidaysForYear_(currentYear);
        if (options.sedrot) {
          sedra = getSedra_(currentYear, il);
        }
        if (options.omer) {
          beginOmer = HDate.hebrew2abs(currentYear, NISAN, 16);
          endOmer = HDate.hebrew2abs(currentYear, SIVAN, 5);
        }
      }
      const prevEventsLength = evts.length;
      const dow = hd.getDay();
      let candlesEv = undefined;
      const ev = holidaysYear.get(hd.toString()) || [];
      ev.forEach(e => {
        candlesEv = appendHolidayAndRelated(evts, e, options, candlesEv, dow);
      });
      if (options.sedrot && dow === SAT) {
        const parsha0 = sedra.lookup(abs);
        if (!parsha0.chag) {
          evts.push(new ParshaEvent(hd, parsha0.parsha, il, parsha0.num));
        }
      }
      const dailyLearning = options.dailyLearning;
      if (typeof dailyLearning === 'object') {
        Object.entries(dailyLearning).forEach(kv => {
          const key = kv[0];
          const val = kv[1];
          if (val) {
            const name = key === 'yerushalmi' ? val === 2 ? 'yerushalmi-schottenstein' : 'yerushalmi-vilna' : key;
            const learningEv = DailyLearning.lookup(name, hd);
            if (learningEv) {
              evts.push(learningEv);
            }
          }
        });
      }
      if (options.omer && abs >= beginOmer && abs <= endOmer) {
        const omer = abs - beginOmer + 1;
        const omerEv = new OmerEvent(hd, omer);
        if (options.candlelighting) {
          const zmanim = new Zmanim(hd.prev(), location.getLatitude(), location.getLongitude());
          const tzeit = zmanim.tzeit(7.0833);
          if (!isNaN(tzeit.getTime())) {
            omerEv.alarm = tzeit;
          }
        }
        evts.push(omerEv);
      }
      const hmonth = hd.getMonth();
      if (options.molad && dow == SAT && hmonth != ELUL && hd.getDate() >= 23 && hd.getDate() <= 29) {
        const monNext = hmonth == HDate.monthsInYear(hyear) ? NISAN : hmonth + 1;
        evts.push(new MoladEvent(hd, hyear, monNext));
      }
      if (!candlesEv && options.candlelighting && (dow == FRI || dow == SAT)) {
        candlesEv = makeCandleEvent(undefined, hd, dow, location, options);
        if (dow === FRI && candlesEv && sedra) {
          candlesEv.memo = sedra.getString(abs);
        }
      }
      // suppress Havdalah when options.havdalahMins=0 or options.havdalahDeg=0
      if (candlesEv instanceof HavdalahEvent && (options.havdalahMins === 0 || options.havdalahDeg === 0)) {
        candlesEv = null;
      }
      if (candlesEv) {
        evts.push(candlesEv);
      }
      if (options.addHebrewDates || options.addHebrewDatesForEvents && prevEventsLength != evts.length) {
        const e2 = new HebrewDateEvent(hd);
        if (prevEventsLength == evts.length) {
          evts.push(e2);
        } else {
          evts.splice(prevEventsLength, 0, e2);
        }
      }
    }
    return evts;
  }

  /**
   * Calculates a birthday or anniversary (non-yahrzeit).
   * `hyear` must be after original `gdate` of anniversary.
   * Returns `undefined` when requested year preceeds or is same as original year.
   *
   * Hebcal uses the algorithm defined in "Calendrical Calculations"
   * by Edward M. Reingold and Nachum Dershowitz.
   *
   * The birthday of someone born in Adar of an ordinary year or Adar II of
   * a leap year is also always in the last month of the year, be that Adar
   * or Adar II. The birthday in an ordinary year of someone born during the
   * first 29 days of Adar I in a leap year is on the corresponding day of Adar;
   * in a leap year, the birthday occurs in Adar I, as expected.
   *
   * Someone born on the thirtieth day of Marcheshvan, Kislev, or Adar I
   * has his birthday postponed until the first of the following month in
   * years where that day does not occur. [Calendrical Calculations p. 111]
   * @example
   * import {HebrewCalendar} from '@hebcal/core';
   * const dt = new Date(2014, 2, 2); // '2014-03-02' == '30 Adar I 5774'
   * const hd = HebrewCalendar.getBirthdayOrAnniversary(5780, dt); // '1 Nisan 5780'
   * console.log(hd.greg().toLocaleDateString('en-US')); // '3/26/2020'
   * @param {number} hyear Hebrew year
   * @param {Date|HDate} gdate Gregorian or Hebrew date of event
   * @return {HDate} anniversary occurring in `hyear`
   */
  static getBirthdayOrAnniversary(hyear, gdate) {
    return getBirthdayOrAnniversary_(hyear, gdate);
  }

  /**
   * Calculates yahrzeit.
   * `hyear` must be after original `gdate` of death.
   * Returns `undefined` when requested year preceeds or is same as original year.
   *
   * Hebcal uses the algorithm defined in "Calendrical Calculations"
   * by Edward M. Reingold and Nachum Dershowitz.
   *
   * The customary anniversary date of a death is more complicated and depends
   * also on the character of the year in which the first anniversary occurs.
   * There are several cases:
   *
   * * If the date of death is Marcheshvan 30, the anniversary in general depends
   *   on the first anniversary; if that first anniversary was not Marcheshvan 30,
   *   use the day before Kislev 1.
   * * If the date of death is Kislev 30, the anniversary in general again depends
   *   on the first anniversary — if that was not Kislev 30, use the day before
   *   Tevet 1.
   * * If the date of death is Adar II, the anniversary is the same day in the
   *   last month of the Hebrew year (Adar or Adar II).
   * * If the date of death is Adar I 30, the anniversary in a Hebrew year that
   *   is not a leap year (in which Adar only has 29 days) is the last day in
   *   Shevat.
   * * In all other cases, use the normal (that is, same month number) anniversary
   *   of the date of death. [Calendrical Calculations p. 113]
   * @example
   * import {HebrewCalendar} from '@hebcal/core';
   * const dt = new Date(2014, 2, 2); // '2014-03-02' == '30 Adar I 5774'
   * const hd = HebrewCalendar.getYahrzeit(5780, dt); // '30 Sh\'vat 5780'
   * console.log(hd.greg().toLocaleDateString('en-US')); // '2/25/2020'
   * @param {number} hyear Hebrew year
   * @param {Date|HDate} gdate Gregorian or Hebrew date of death
   * @return {HDate} anniversary occurring in hyear
   */
  static getYahrzeit(hyear, gdate) {
    return getYahrzeit_(hyear, gdate);
  }

  /**
   * Lower-level holidays interface, which returns a `Map` of `Event`s indexed by
   * `HDate.toString()`. These events must filtered especially for `flags.IL_ONLY`
   * or `flags.CHUL_ONLY` depending on Israel vs. Diaspora holiday scheme.
   * @function
   * @param {number} year Hebrew year
   * @return {Map<string,Event[]>}
   */
  static getHolidaysForYear(year) {
    return getHolidaysForYear_(year);
  }

  /**
   * Returns an array of holidays for the year
   * @param {number} year Hebrew year
   * @param {boolean} il use the Israeli schedule for holidays
   * @return {Event[]}
   */
  static getHolidaysForYearArray(year, il) {
    const cacheKey = `${year}-${il ? 1 : 0}`;
    let events = yearArrayCache[cacheKey];
    if (events) {
      return events;
    }
    const yearMap = getHolidaysForYear_(year);
    const startAbs = HDate.hebrew2abs(year, TISHREI, 1);
    const endAbs = HDate.hebrew2abs(year + 1, TISHREI, 1) - 1;
    events = [];
    const myFilter = il ? observedInIsrael : observedInDiaspora;
    for (let absDt = startAbs; absDt <= endAbs; absDt++) {
      const hd = new HDate(absDt);
      const holidays = yearMap.get(hd.toString());
      if (holidays) {
        const filtered = holidays.filter(myFilter);
        events = events.concat(filtered);
      }
    }
    yearArrayCache[cacheKey] = events;
    return events;
  }

  /**
   * Returns an array of Events on this date (or undefined if no events)
   * @param {HDate|Date|number} date Hebrew Date, Gregorian date, or absolute R.D. day number
   * @param {boolean} [il] use the Israeli schedule for holidays
   * @return {Event[]}
   */
  static getHolidaysOnDate(date, il) {
    const hd = HDate.isHDate(date) ? date : new HDate(date);
    const yearMap = getHolidaysForYear_(hd.getFullYear());
    const events = yearMap.get(hd.toString());
    if (typeof il === 'undefined' || typeof events === 'undefined') {
      return events;
    }
    const myFilter = il ? observedInIsrael : observedInDiaspora;
    return events.filter(myFilter);
  }

  /**
   * Helper function to format a 23-hour (00:00-23:59) time in US format ("8:13pm") or
   * keep as "20:13" for any other locale/country. Uses {@link CalOptions} to determine
   * locale.
   * If `options.hour12` is `false`, locale is ignored and always returns 24-hour time.
   * If `options.hour12` is `true`, locale is ignored and always returns 12-hour time.
   * @param {string} timeStr - original time like "20:30"
   * @param {string} suffix - "p" or "pm" or " P.M.". Add leading space if you want it
   * @param {CalOptions} options
   * @return {string}
   */
  static reformatTimeStr(timeStr, suffix, options) {
    if (typeof timeStr !== 'string') throw new TypeError(`Bad timeStr: ${timeStr}`);
    const cc = options.location && options.location.cc || (options.il ? 'IL' : 'US');
    if (typeof options.hour12 !== 'undefined' && !options.hour12) {
      return timeStr;
    }
    if (!options.hour12 && typeof hour12cc[cc] === 'undefined') {
      return timeStr;
    }
    const hm = timeStr.split(':');
    let hour = parseInt(hm[0], 10);
    if (hour < 12 && suffix) {
      suffix = suffix.replace('p', 'a').replace('P', 'A');
    } else if (hour > 12) {
      hour = hour % 12;
    }
    return `${hour}:${hm[1]}${suffix}`;
  }

  /** @return {string} */
  static version() {
    return version;
  }

  /**
   * Convenience function to create an instance of `Sedra` or reuse a previously
   * created and cached instance.
   * @function
   * @param {number} hyear
   * @param {boolean} il
   * @return {Sedra}
   */
  static getSedra(hyear, il) {
    return getSedra_(hyear, il);
  }

  /**
   * Return a number containing information on what Hallel is said on that day.
   *
   * Whole Hallel is said on Chanukah, the first Yom Tov of Pesach, Shavuot, Sukkot,
   * Yom Ha'atzmaut, and Yom Yerushalayim.
   *
   * Half Hallel is said on Rosh Chodesh (not Rosh Hashanah), and the last 6 days of Pesach.
   *
   * The number is one of the following values:
   *
   * 0 - No Hallel
   * 1 - Half Hallel
   * 2 - Whole Hallel
   *
   * @param {HDate} hdate
   * @param {boolean} il
   * @return {number}
   */
  static hallel(hdate, il) {
    const events = HebrewCalendar.getHolidaysForYearArray(hdate.getFullYear(), il);
    return hallel_(events, hdate);
  }

  /**
   * Return details on what Tachanun (or Tzidchatcha on Shabbat) is said on `hdate`.
   *
   * Tachanun is not said on Rosh Chodesh, the month of Nisan, Lag Baomer,
   * Rosh Chodesh Sivan until Isru Chag, Tisha B'av, 15 Av, Erev Rosh Hashanah,
   * Rosh Hashanah, Erev Yom Kippur until after Simchat Torah, Chanukah,
   * Tu B'shvat, Purim and Shushan Purim, and Purim and Shushan Purim Katan.
   *
   * In some congregations Tachanun is not said until from Rosh Chodesh Sivan
   * until 14th Sivan, Sukkot until after Rosh Chodesh Cheshvan, Pesach Sheini,
   * Yom Ha'atzmaut, and Yom Yerushalayim.
   *
   * Tachanun is not said at Mincha on days before it is not said at Shacharit.
   *
   * Tachanun is not said at Shacharit on Shabbat, but is at Mincha, usually.
   * @param {HDate} hdate
   * @param {boolean} il
   * @return {TachanunResult}
   */
  static tachanun(hdate, il) {
    return tachanun_(hdate, il);
  }
}

/**
 * Appends the Event `ev` to the `events` array. Also may add related
 * timed events like candle-lighting or fast start/end
 * @private
 * @param {Event[]} events
 * @param {Event} ev
 * @param {CalOptions} options
 * @param {Event} candlesEv
 * @param {number} dow
 * @return {Event}
 */
function appendHolidayAndRelated(events, ev, options, candlesEv, dow) {
  const il = options.il;
  if (!ev.observedIn(il)) {
    return candlesEv; // holiday isn't observed here; bail out early
  }

  const eFlags = ev.getFlags();
  if (!options.yomKippurKatan && eFlags & flags.YOM_KIPPUR_KATAN || options.noModern && eFlags & MODERN_HOLIDAY) {
    return candlesEv; // bail out early
  }

  const location = options.location;
  const isMajorFast = Boolean(eFlags & MAJOR_FAST);
  const isMinorFast = Boolean(eFlags & MINOR_FAST);
  if (options.candlelighting && (isMajorFast || isMinorFast)) {
    ev = makeFastStartEnd(ev, location);
    if (ev.startEvent && (isMajorFast || isMinorFast && !options.noMinorFast)) {
      events.push(ev.startEvent);
    }
  }
  if (eFlags & options.mask || !eFlags && !options.userMask) {
    if (options.candlelighting && eFlags & MASK_LIGHT_CANDLES) {
      const hd = ev.getDate();
      candlesEv = makeCandleEvent(ev, hd, dow, location, options);
      if (eFlags & CHANUKAH_CANDLES && candlesEv && !options.noHolidays) {
        const chanukahEv = dow === FRI || dow === SAT ? candlesEv : makeWeekdayChanukahCandleLighting(ev, hd, location);
        const attrs = {
          eventTime: chanukahEv.eventTime,
          eventTimeStr: chanukahEv.eventTimeStr,
          location
        };
        if (ev.chanukahDay) attrs.chanukahDay = ev.chanukahDay;
        if (ev.emoji) attrs.emoji = ev.emoji;
        // Replace Chanukah event with a clone that includes candle lighting time.
        // For clarity, allow a "duplicate" candle lighting event to remain for Shabbat
        ev = new HolidayEvent(ev.getDate(), ev.getDesc(), eFlags, attrs);
        candlesEv = undefined;
      }
    }
    if (options.yomKippurKatan && eFlags & flags.YOM_KIPPUR_KATAN) {
      events.push(ev);
    } else if (!options.noHolidays) {
      events.push(ev); // the original event itself
    }
  }

  if (ev.endEvent && (isMajorFast || isMinorFast && !options.noMinorFast)) {
    events.push(ev.endEvent);
  }
  return candlesEv;
}

exports.AsaraBTevetEvent = AsaraBTevetEvent;
exports.CandleLightingEvent = CandleLightingEvent;
exports.DailyLearning = DailyLearning;
exports.Event = Event;
exports.HDate = HDate;
exports.HavdalahEvent = HavdalahEvent;
exports.HebrewCalendar = HebrewCalendar;
exports.HebrewDateEvent = HebrewDateEvent;
exports.HolidayEvent = HolidayEvent;
exports.Locale = Locale;
exports.Location = Location;
exports.MevarchimChodeshEvent = MevarchimChodeshEvent;
exports.Molad = Molad;
exports.MoladEvent = MoladEvent;
exports.OmerEvent = OmerEvent;
exports.ParshaEvent = ParshaEvent;
exports.RoshChodeshEvent = RoshChodeshEvent;
exports.RoshHashanaEvent = RoshHashanaEvent;
exports.Sedra = Sedra;
exports.SolarCalc = SolarCalc;
exports.TimedEvent = TimedEvent;
exports.Zmanim = Zmanim;
exports.flags = flags;
exports.gematriya = gematriya;
exports.greg = greg;
exports.months = months;
exports.parshiot = parshiot;
exports.version = version;
