/*! @hebcal/core v4.1.1 */
var hebcal = (function (exports) {
'use strict';

var GERESH = '׳';
var GERSHAYIM = '״';

/**
 * @private
 * @param {number} num
 * @return {string}
 */
function num2heb(num) {
  switch (num) {
    case 1:
      return 'א';
    case 2:
      return 'ב';
    case 3:
      return 'ג';
    case 4:
      return 'ד';
    case 5:
      return 'ה';
    case 6:
      return 'ו';
    case 7:
      return 'ז';
    case 8:
      return 'ח';
    case 9:
      return 'ט';
    case 10:
      return 'י';
    case 20:
      return 'כ';
    case 30:
      return 'ל';
    case 40:
      return 'מ';
    case 50:
      return 'נ';
    case 60:
      return 'ס';
    case 70:
      return 'ע';
    case 80:
      return 'פ';
    case 90:
      return 'צ';
    case 100:
      return 'ק';
    case 200:
      return 'ר';
    case 300:
      return 'ש';
    case 400:
      return 'ת';
    default:
      return '*INVALID*';
  }
}

/**
 * @private
 * @param {number} num
 * @return {number[]}
 */
function num2digits(num) {
  var digits = [];
  while (num > 0) {
    if (num === 15 || num === 16) {
      digits.push(9);
      digits.push(num - 9);
      break;
    }
    var incr = 100;
    var i = void 0;
    for (i = 400; i > num; i -= incr) {
      if (i === incr) {
        incr = incr / 10;
      }
    }
    digits.push(i);
    num -= i;
  }
  return digits;
}

/**
 * Converts a numerical value to a string of Hebrew letters.
 *
 * When specifying years of the Hebrew calendar in the present millennium,
 * we omit the thousands (which is presently 5 [ה]).
 * @example
 * gematriya(5774) // 'תשע״ד' - cropped to 774
 * gematriya(25) // 'כ״ה'
 * gematriya(60) // 'ס׳'
 * gematriya(3761) // 'ג׳תשס״א'
 * gematriya(1123) // 'א׳קכ״ג'
 * @param {number} number
 * @return {string}
 */
function gematriya(number) {
  var num = parseInt(number, 10);
  if (!num) {
    throw new TypeError("invalid parameter to gematriya ".concat(number));
  }
  var str = '';
  var thousands = Math.floor(num / 1000);
  if (thousands > 0 && thousands !== 5) {
    var tdigits = num2digits(thousands);
    for (var i = 0; i < tdigits.length; i++) {
      str += num2heb(tdigits[i]);
    }
    str += GERESH;
  }
  var digits = num2digits(num % 1000);
  if (digits.length == 1) {
    return str + num2heb(digits[0]) + GERESH;
  }
  for (var _i = 0; _i < digits.length; _i++) {
    if (_i + 1 === digits.length) {
      str += GERSHAYIM;
    }
    str += num2heb(digits[_i]);
  }
  return str;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

/*
 * More minimal greg routines
 */

/** @private */
var lengths = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
/** @private */
var monthLengths = [lengths, lengths.slice()];
monthLengths[1][2] = 29;

/**
 * @private
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
function mod(x, y) {
  return x - y * Math.floor(x / y);
}

/**
 * @private
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
function quotient(x, y) {
  return Math.floor(x / y);
}

/**
 * Returns true if the Gregorian year is a leap year
 * @private
 * @param {number} year Gregorian year
 * @return {boolean}
 */
function isLeapYear$1(year) {
  return !(year % 4) && (!!(year % 100) || !(year % 400));
}

/**
 * Number of days in the Gregorian month for given year
 * @private
 * @param {number} month Gregorian month (1=January, 12=December)
 * @param {number} year Gregorian year
 * @return {number}
 */
function daysInMonth$1(month, year) {
  // 1 based months
  return monthLengths[+isLeapYear$1(year)][month];
}

/**
 * Returns true if the object is a Javascript Date
 * @private
 * @param {Object} obj
 * @return {boolean}
 */
function isDate(obj) {
  return _typeof(obj) === 'object' && Date.prototype === obj.__proto__;
}

/*
const ABS_14SEP1752 = 639797;
const ABS_2SEP1752 = 639785;
*/

/**
 * Converts Gregorian date to absolute R.D. (Rata Die) days
 * @private
 * @param {Date} date Gregorian date
 * @return {number}
 */
function greg2abs(date) {
  if (!isDate(date)) {
    throw new TypeError("Argument not a Date: ".concat(date));
  }
  var abs = toFixed(date.getFullYear(), date.getMonth() + 1, date.getDate());
  /*
  if (abs < ABS_14SEP1752 && abs > ABS_2SEP1752) {
    throw new RangeError(`Invalid Date: ${date}`);
  }
  */
  return abs;
}

/**
 * @private
 * @param {number} abs - R.D. number of days
 * @return {number}
 */
function yearFromFixed(abs) {
  var l0 = abs - 1;
  var n400 = quotient(l0, 146097);
  var d1 = mod(l0, 146097);
  var n100 = quotient(d1, 36524);
  var d2 = mod(d1, 36524);
  var n4 = quotient(d2, 1461);
  var d3 = mod(d2, 1461);
  var n1 = quotient(d3, 365);
  var year = 400 * n400 + 100 * n100 + 4 * n4 + n1;
  return n100 != 4 && n1 != 4 ? year + 1 : year;
}

/**
 * @private
 * @param {number} year
 * @param {number} month (1-12)
 * @param {number} day (1-31)
 * @return {number}
 */
function toFixed(year, month, day) {
  var py = year - 1;
  return 365 * py + quotient(py, 4) - quotient(py, 100) + quotient(py, 400) + quotient(367 * month - 362, 12) + (month <= 2 ? 0 : isLeapYear$1(year) ? -1 : -2) + day;
}

/**
 * Converts from Rata Die (R.D. number) to Gregorian date.
 * See the footnote on page 384 of ``Calendrical Calculations, Part II:
 * Three Historical Calendars'' by E. M. Reingold,  N. Dershowitz, and S. M.
 * Clamen, Software--Practice and Experience, Volume 23, Number 4
 * (April, 1993), pages 383-404 for an explanation.
 * @private
 * @param {number} abs - R.D. number of days
 * @return {Date}
 */
function abs2greg(abs) {
  if (typeof abs !== 'number') {
    throw new TypeError("Argument not a Number: ".concat(abs));
  }
  abs = Math.trunc(abs);
  /*
  if (abs < ABS_14SEP1752 && abs > ABS_2SEP1752) {
    throw new RangeError(`Invalid Date: ${abs}`);
  }
  */
  var year = yearFromFixed(abs);
  var priorDays = abs - toFixed(year, 1, 1);
  var correction = abs < toFixed(year, 3, 1) ? 0 : isLeapYear$1(year) ? 1 : 2;
  var month = quotient(12 * (priorDays + correction) + 373, 367);
  var day = abs - toFixed(year, month, 1) + 1;
  var dt = new Date(year, month - 1, day);
  if (year < 100 && year >= 0) {
    dt.setFullYear(year);
  }
  return dt;
}

/*
    Hebcal - A Jewish Calendar Generator
    Copyright (c) 1994-2020 Danny Sadinoff
    Portions copyright Eyal Schachter and Michael J. Radwin

    https://github.com/hebcal/hebcal-es6

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * Gregorian date helper functions.
 */
var greg = {
  /**
   * Long names of the Gregorian months (1='January', 12='December')
   * @readonly
   * @type {string[]}
   */
  monthNames: ['', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
  /**
   * Returns true if the Gregorian year is a leap year
   * @function
   * @param {number} year Gregorian year
   * @return {boolean}
   */
  isLeapYear: isLeapYear$1,
  /**
   * Number of days in the Gregorian month for given year
   * @function
   * @param {number} month Gregorian month (1=January, 12=December)
   * @param {number} year Gregorian year
   * @return {number}
   */
  daysInMonth: daysInMonth$1,
  /**
   * Returns true if the object is a Javascript Date
   * @function
   * @param {Object} obj
   * @return {boolean}
   */
  isDate: isDate,
  /**
   * Returns number of days since January 1 of that year
   * @deprecated
   * @param {Date} date Gregorian date
   * @return {number}
   */
  dayOfYear: function dayOfYear(date) {
    if (!isDate(date)) {
      throw new TypeError("Argument not a Date: ".concat(date));
    }
    var month = date.getMonth();
    var doy = date.getDate() + 31 * month;
    if (month > 1) {
      // FEB
      doy -= Math.floor((4 * (month + 1) + 23) / 10);
      if (isLeapYear$1(date.getFullYear())) {
        doy++;
      }
    }
    return doy;
  },
  /**
   * Converts Gregorian date to absolute R.D. (Rata Die) days
   * @function
   * @param {Date} date Gregorian date
   * @return {number}
   */
  greg2abs: greg2abs,
  /**
   * Converts from Rata Die (R.D. number) to Gregorian date.
   * See the footnote on page 384 of ``Calendrical Calculations, Part II:
   * Three Historical Calendars'' by E. M. Reingold,  N. Dershowitz, and S. M.
   * Clamen, Software--Practice and Experience, Volume 23, Number 4
   * (April, 1993), pages 383-404 for an explanation.
   * @function
   * @param {number} theDate - R.D. number of days
   * @return {Date}
   */
  abs2greg: abs2greg
};

var noopLocale = {
  headers: {
    'plural-forms': 'nplurals=2; plural=(n!=1);'
  },
  contexts: {
    '': {}
  }
};
var alias = {
  'h': 'he',
  'a': 'ashkenazi',
  's': 'en',
  '': 'en'
};

/** @private */
var locales = Object.create(null);
/** @private */
var activeLocale = null;
/** @private */
var activeName = null;

/**
 * A locale in Hebcal is used for translations/transliterations of
 * holidays. `@hebcal/core` supports four locales by default
 * * `en` - default, Sephardic transliterations (e.g. "Shabbat")
 * * `ashkenazi` - Ashkenazi transliterations (e.g. "Shabbos")
 * * `he` - Hebrew (e.g. "שַׁבָּת")
 * * `he-x-NoNikud` - Hebrew without nikud (e.g. "שבת")
 */
var Locale = /*#__PURE__*/function () {
  function Locale() {
    _classCallCheck(this, Locale);
  }
  _createClass(Locale, null, [{
    key: "lookupTranslation",
    value:
    /**
     * Returns translation only if `locale` offers a non-empty translation for `id`.
     * Otherwise, returns `undefined`.
     * @param {string} id Message ID to translate
     * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
     * @return {string}
     */
    function lookupTranslation(id, locale) {
      var locale0 = locale && locale.toLowerCase();
      var loc = typeof locale == 'string' && locales[locale0] || activeLocale;
      var array = loc[id];
      if (array && array.length && array[0].length) {
        return array[0];
      }
      return undefined;
    }

    /**
     * By default, if no translation was found, returns `id`.
     * @param {string} id Message ID to translate
     * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
     * @return {string}
     */
  }, {
    key: "gettext",
    value: function gettext(id, locale) {
      var text = this.lookupTranslation(id, locale);
      if (typeof text == 'undefined') {
        return id;
      }
      return text;
    }

    /**
     * Register locale translations.
     * @param {string} locale Locale name (i.e.: `'he'`, `'fr'`)
     * @param {LocaleData} data parsed data from a `.po` file.
     */
  }, {
    key: "addLocale",
    value: function addLocale(locale, data) {
      if (typeof locale !== 'string') {
        throw new TypeError("Invalid locale name: ".concat(locale));
      }
      if (_typeof(data.contexts) !== 'object' || _typeof(data.contexts['']) !== 'object') {
        throw new TypeError("Locale '".concat(locale, "' invalid compact format"));
      }
      locales[locale.toLowerCase()] = data.contexts[''];
    }

    /**
     * Adds a translation to `locale`, replacing any previous translation.
     * @param {string} locale Locale name (i.e: `'he'`, `'fr'`).
     * @param {string} id Message ID to translate
     * @param {string} translation Translation text
     */
  }, {
    key: "addTranslation",
    value: function addTranslation(locale, id, translation) {
      if (typeof locale !== 'string') {
        throw new TypeError("Invalid locale name: ".concat(locale));
      }
      var locale0 = locale.toLowerCase();
      var loc = locales[locale0];
      if (!loc) {
        throw new TypeError("Unknown locale: ".concat(locale));
      }
      if (typeof id !== 'string' || id.length === 0) {
        throw new TypeError("Invalid id: ".concat(id));
      }
      var isArray = Array.isArray(translation);
      if (isArray) {
        var t0 = translation[0];
        if (typeof t0 !== 'string' || t0.length === 0) {
          throw new TypeError("Invalid translation array: ".concat(translation));
        }
      } else if (typeof translation !== 'string') {
        throw new TypeError("Invalid translation: ".concat(translation));
      }
      loc[id] = isArray ? translation : [translation];
    }
    /**
     * Adds multiple translations to `locale`, replacing any previous translations.
     * @param {string} locale Locale name (i.e: `'he'`, `'fr'`).
     * @param {LocaleData} data parsed data from a `.po` file.
     */
  }, {
    key: "addTranslations",
    value: function addTranslations(locale, data) {
      if (typeof locale !== 'string') {
        throw new TypeError("Invalid locale name: ".concat(locale));
      }
      var locale0 = locale.toLowerCase();
      var loc = locales[locale0];
      if (!loc) {
        throw new TypeError("Unknown locale: ".concat(locale));
      }
      if (_typeof(data.contexts) !== 'object' || _typeof(data.contexts['']) !== 'object') {
        throw new TypeError("Locale '".concat(locale, "' invalid compact format"));
      }
      var ctx = data.contexts[''];
      Object.keys(ctx).forEach(function (id) {
        loc[id] = ctx[id];
      });
    }
    /**
     * Activates a locale. Throws an error if the locale has not been previously added.
     * After setting the locale to be used, all strings marked for translations
     * will be represented by the corresponding translation in the specified locale.
     * @param {string} locale Locale name (i.e: `'he'`, `'fr'`)
     * @return {LocaleData}
     */
  }, {
    key: "useLocale",
    value: function useLocale(locale) {
      var locale0 = locale.toLowerCase();
      var obj = locales[locale0];
      if (!obj) {
        throw new RangeError("Locale '".concat(locale, "' not found"));
      }
      activeName = alias[locale0] || locale0;
      activeLocale = obj;
      return activeLocale;
    }

    /**
     * Returns the name of the active locale (i.e. 'he', 'ashkenazi', 'fr')
     * @return {string}
     */
  }, {
    key: "getLocaleName",
    value: function getLocaleName() {
      return activeName;
    }

    /**
     * Returns the names of registered locales
     * @return {string[]}
     */
  }, {
    key: "getLocaleNames",
    value: function getLocaleNames() {
      return Object.keys(locales).sort();
    }

    /**
     * @param {number} n
     * @param {string} [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
     * @return {string}
     */
  }, {
    key: "ordinal",
    value: function ordinal(n, locale) {
      var locale1 = locale && locale.toLowerCase();
      var locale0 = locale1 || activeName;
      if (!locale0) {
        return this.getEnOrdinal(n);
      }
      switch (locale0) {
        case 'en':
        case 's':
        case 'a':
        case 'ashkenazi':
        case 'ashkenazi_litvish':
        case 'ashkenazi_poylish':
        case 'ashkenazi_standard':
          return this.getEnOrdinal(n);
        case 'es':
          return n + 'º';
        case 'h':
        case 'he':
        case 'he-x-nonikud':
          return String(n);
        default:
          return n + '.';
      }
    }

    /**
     * @private
     * @param {number} n
     * @return {string}
     */
  }, {
    key: "getEnOrdinal",
    value: function getEnOrdinal(n) {
      var s = ['th', 'st', 'nd', 'rd'];
      var v = n % 100;
      return n + (s[(v - 20) % 10] || s[v] || s[0]);
    }

    /**
     * Removes nekudot from Hebrew string
     * @param {string} str
     * @return {string}
     */
  }, {
    key: "hebrewStripNikkud",
    value: function hebrewStripNikkud(str) {
      return str.replace(/[\u0590-\u05bd]/g, '').replace(/[\u05bf-\u05c7]/g, '');
    }
  }]);
  return Locale;
}();
Locale.addLocale('en', noopLocale);
Locale.addLocale('s', noopLocale);
Locale.addLocale('', noopLocale);
Locale.useLocale('en');

/*
 * More minimal HDate
 */

var NISAN$1 = 1;
var IYYAR = 2;
// const SIVAN = 3;
var TAMUZ = 4;
// const AV = 5;
var ELUL = 6;
var TISHREI = 7;
var CHESHVAN$1 = 8;
var KISLEV$1 = 9;
var TEVET$1 = 10;
// const SHVAT = 11;
var ADAR_I$1 = 12;
var ADAR_II$1 = 13;

/**
 * Hebrew months of the year (NISAN=1, TISHREI=7)
 * @readonly
 * @enum {number}
 */
var months = {
  /** Nissan / ניסן */
  NISAN: 1,
  /** Iyyar / אייר */
  IYYAR: 2,
  /** Sivan / סיון */
  SIVAN: 3,
  /** Tamuz (sometimes Tammuz) / תמוז */
  TAMUZ: 4,
  /** Av / אב */
  AV: 5,
  /** Elul / אלול */
  ELUL: 6,
  /** Tishrei / תִשְׁרֵי */
  TISHREI: 7,
  /** Cheshvan / חשון */
  CHESHVAN: 8,
  /** Kislev / כסלו */
  KISLEV: 9,
  /** Tevet / טבת */
  TEVET: 10,
  /** Sh'vat / שבט */
  SHVAT: 11,
  /** Adar or Adar Rishon / אדר */
  ADAR_I: 12,
  /** Adar Sheini (only on leap years) / אדר ב׳ */
  ADAR_II: 13
};
var monthNames0 = ['', 'Nisan', 'Iyyar', 'Sivan', 'Tamuz', 'Av', 'Elul', 'Tishrei', 'Cheshvan', 'Kislev', 'Tevet', 'Sh\'vat'];

/**
 * Transliterations of Hebrew month names.
 * Regular years are index 0 and leap years are index 1.
 * @private
 */
var monthNames = [monthNames0.concat(['Adar', 'Nisan']), monthNames0.concat(['Adar I', 'Adar II', 'Nisan'])];
var edCache = Object.create(null);
var EPOCH = -1373428;
// Avg year length in the cycle (19 solar years with 235 lunar months)
var AVG_HEBYEAR_DAYS = 365.24682220597794;

/**
 * @private
 * @param {any} n
 * @param {string} name
 */
function assertNumber(n, name) {
  if (typeof n !== 'number' || isNaN(n)) {
    throw new TypeError("invalid parameter '".concat(name, "' not a number: ").concat(n));
  }
}

/**
 * Converts Hebrew date to R.D. (Rata Die) fixed days.
 * R.D. 1 is the imaginary date Monday, January 1, 1 on the Gregorian
 * Calendar.
 * @private
 * @param {number} year Hebrew year
 * @param {number} month Hebrew month
 * @param {number} day Hebrew date (1-30)
 * @return {number}
 */
function hebrew2abs(year, month, day) {
  assertNumber(year, 'year');
  assertNumber(month, 'month');
  assertNumber(day, 'day');
  if (year < 1) {
    throw new RangeError("hebrew2abs: invalid year ".concat(year));
  }
  var tempabs = day;
  if (month < TISHREI) {
    for (var m = TISHREI; m <= monthsInYear(year); m++) {
      tempabs += daysInMonth(m, year);
    }
    for (var _m = NISAN$1; _m < month; _m++) {
      tempabs += daysInMonth(_m, year);
    }
  } else {
    for (var _m2 = TISHREI; _m2 < month; _m2++) {
      tempabs += daysInMonth(_m2, year);
    }
  }
  return EPOCH + elapsedDays(year) + tempabs - 1;
}

/**
 * @private
 * @param {number} year
 * @return {number}
 */
function newYear(year) {
  return EPOCH + elapsedDays(year);
}

/**
 * Converts absolute R.D. days to Hebrew date
 * @private
 * @param {number} abs absolute R.D. days
 * @return {SimpleHebrewDate}
 */
function abs2hebrew(abs) {
  assertNumber(abs, 'abs');
  abs = Math.trunc(abs);
  if (abs <= EPOCH) {
    throw new RangeError("abs2hebrew: ".concat(abs, " is before epoch"));
  }
  // first, quickly approximate year
  var year = Math.floor((abs - EPOCH) / AVG_HEBYEAR_DAYS);
  while (newYear(year) <= abs) {
    ++year;
  }
  --year;
  var month = abs < hebrew2abs(year, 1, 1) ? 7 : 1;
  while (abs > hebrew2abs(year, month, daysInMonth(month, year))) {
    ++month;
  }
  var day = 1 + abs - hebrew2abs(year, month, 1);
  return {
    yy: year,
    mm: month,
    dd: day
  };
}

/**
 * Returns true if Hebrew year is a leap year
 * @private
 * @param {number} year Hebrew year
 * @return {boolean}
 */
function isLeapYear(year) {
  return (1 + year * 7) % 19 < 7;
}

/**
 * Number of months in this Hebrew year (either 12 or 13 depending on leap year)
 * @private
 * @param {number} year Hebrew year
 * @return {number}
 */
function monthsInYear(year) {
  return 12 + isLeapYear(year); // boolean is cast to 1 or 0
}

/**
 * Number of days in Hebrew month in a given year (29 or 30)
 * @private
 * @param {number} month Hebrew month (e.g. months.TISHREI)
 * @param {number} year Hebrew year
 * @return {number}
 */
function daysInMonth(month, year) {
  switch (month) {
    case IYYAR:
    case TAMUZ:
    case ELUL:
    case TEVET$1:
    case ADAR_II$1:
      return 29;
  }
  if (month === ADAR_I$1 && !isLeapYear(year) || month === CHESHVAN$1 && !longCheshvan(year) || month === KISLEV$1 && shortKislev(year)) {
    return 29;
  } else {
    return 30;
  }
}

/**
 * Returns a transliterated string name of Hebrew month in year,
 * for example 'Elul' or 'Cheshvan'.
 * @private
 * @param {number} month Hebrew month (e.g. months.TISHREI)
 * @param {number} year Hebrew year
 * @return {string}
 */
function getMonthName(month, year) {
  assertNumber(month, 'month');
  assertNumber(year, 'year');
  if (month < 1 || month > 14) {
    throw new TypeError("bad month argument ".concat(month));
  }
  return monthNames[+isLeapYear(year)][month];
}

/**
 * Days from sunday prior to start of Hebrew calendar to mean
 * conjunction of Tishrei in Hebrew YEAR
 * @private
 * @param {number} year Hebrew year
 * @return {number}
 */
function elapsedDays(year) {
  var elapsed = edCache[year] = edCache[year] || elapsedDays0(year);
  return elapsed;
}

/**
 * Days from sunday prior to start of Hebrew calendar to mean
 * conjunction of Tishrei in Hebrew YEAR
 * @private
 * @param {number} year Hebrew year
 * @return {number}
 */
function elapsedDays0(year) {
  var prevYear = year - 1;
  var mElapsed = 235 * Math.floor(prevYear / 19) +
  // Months in complete 19 year lunar (Metonic) cycles so far
  12 * (prevYear % 19) +
  // Regular months in this cycle
  Math.floor((prevYear % 19 * 7 + 1) / 19); // Leap months this cycle

  var pElapsed = 204 + 793 * (mElapsed % 1080);
  var hElapsed = 5 + 12 * mElapsed + 793 * Math.floor(mElapsed / 1080) + Math.floor(pElapsed / 1080);
  var parts = pElapsed % 1080 + 1080 * (hElapsed % 24);
  var day = 1 + 29 * mElapsed + Math.floor(hElapsed / 24);
  var altDay = day + (parts >= 19440 || 2 === day % 7 && parts >= 9924 && !isLeapYear(year) || 1 === day % 7 && parts >= 16789 && isLeapYear(prevYear));
  return altDay + (altDay % 7 === 0 || altDay % 7 === 3 || altDay % 7 === 5);
}

/**
 * Number of days in the hebrew YEAR.
 * A common Hebrew calendar year can have a length of 353, 354 or 355 days
 * A leap Hebrew calendar year can have a length of 383, 384 or 385 days
 * @private
 * @param {number} year Hebrew year
 * @return {number}
 */
function daysInYear(year) {
  return elapsedDays(year + 1) - elapsedDays(year);
}

/**
 * true if Cheshvan is long in Hebrew year
 * @private
 * @param {number} year Hebrew year
 * @return {boolean}
 */
function longCheshvan(year) {
  return daysInYear(year) % 10 === 5;
}

/**
 * true if Kislev is short in Hebrew year
 * @private
 * @param {number} year Hebrew year
 * @return {boolean}
 */
function shortKislev(year) {
  return daysInYear(year) % 10 === 3;
}

/**
 * @private
 * @param {string} msg
 */
function throwTypeError(msg) {
  throw new TypeError(msg);
}

var UNITS_DAY = 'day';
var UNITS_WEEK = 'week';
var UNITS_MONTH = 'month';
var UNITS_YEAR = 'year';
var UNITS_SINGLE = {
  d: UNITS_DAY,
  w: UNITS_WEEK,
  M: UNITS_MONTH,
  y: UNITS_YEAR
};
var UNITS_VALID = {
  day: UNITS_DAY,
  week: UNITS_WEEK,
  month: UNITS_MONTH,
  year: UNITS_YEAR
};

/**
 * A simple Hebrew date object with numeric fields `yy`, `mm`, and `dd`
 * @typedef {Object} SimpleHebrewDate
 * @property {number} yy Hebrew year
 * @property {number} mm Hebrew month of year (1=NISAN, 7=TISHREI)
 * @property {number} dd Day of month (1-30)
 * @private
 */

/** Represents a Hebrew date */
var HDate = /*#__PURE__*/function () {
  /**
   * Create a Hebrew date. There are 3 basic forms for the `HDate()` constructor.
   *
   * 1. No parameters - represents the current Hebrew date at time of instantiation
   * 2. One parameter
   *    * `Date` - represents the Hebrew date corresponding to the Gregorian date using
   *       local time. Hours, minutes, seconds and milliseconds are ignored.
   *    * `HDate` - clones a copy of the given Hebrew date
   *    * `number` - Converts absolute R.D. days to Hebrew date.
   *       R.D. 1 == the imaginary date January 1, 1 (Gregorian)
   * 3. Three parameters: Hebrew day, Hebrew month, Hebrew year. Hebrew day should
   *    be a number between 1-30, Hebrew month can be a number or string, and
   *    Hebrew year is always a number.
   * @example
   * import {HDate, months} from '@hebcal/core';
   *
   * const hd1 = new HDate();
   * const hd2 = new HDate(new Date(2008, 10, 13));
   * const hd3 = new HDate(15, 'Cheshvan', 5769);
   * const hd4 = new HDate(15, months.CHESHVAN, 5769);
   * const hd5 = new HDate(733359); // ==> 15 Cheshvan 5769
   * const monthName = 'אייר';
   * const hd6 = new HDate(5, monthName, 5773);
   * @param {number|Date|HDate} [day] - Day of month (1-30) if a `number`.
   *   If a `Date` is specified, represents the Hebrew date corresponding to the
   *   Gregorian date using local time.
   *   If an `HDate` is specified, clones a copy of the given Hebrew date.
   * @param {number|string} [month] - Hebrew month of year (1=NISAN, 7=TISHREI)
   * @param {number} [year] - Hebrew year
   */
  function HDate(day, month, year) {
    _classCallCheck(this, HDate);
    if (arguments.length == 2 || arguments.length > 3) {
      throw new TypeError('HDate constructor requires 0, 1 or 3 arguments');
    }
    if (arguments.length == 3) {
      // Hebrew day, Hebrew month, Hebrew year
      /**
       * @private
       * @type {number}
       */
      this.day = this.month = 1;
      /**
       * @private
       * @type {number}
       */
      year = parseInt(year, 10);
      if (isNaN(year)) {
        throw new TypeError("HDate called with bad year argument: ".concat(year));
      }
      this.year = year;
      this.setMonth(month); // will throw if we can't parse
      day = parseInt(day, 10);
      if (isNaN(day)) {
        throw new TypeError("HDate called with bad day argument: ".concat(day));
      }
      this.setDate(day);
    } else {
      // 0 arguments
      if (typeof day === 'undefined') {
        day = new Date();
      }
      // 1 argument
      var abs0 = typeof day === 'number' && !isNaN(day) ? day : isDate(day) ? greg2abs(day) : HDate.isHDate(day) ? {
        dd: day.day,
        mm: day.month,
        yy: day.year
      } : throwTypeError("HDate called with bad argument: ".concat(day));
      var isNumber = typeof abs0 === 'number';
      var d = isNumber ? abs2hebrew(abs0) : abs0;
      /**
       * @private
       * @type {number}
       */
      this.day = d.dd;
      /**
       * @private
       * @type {number}
       */
      this.month = d.mm;
      /**
       * @private
       * @type {number}
       */
      this.year = d.yy;
      if (isNumber) {
        /**
         * @private
         * @type {number}
         */
        this.abs0 = abs0;
      }
    }
  }

  /**
   * Gets the Hebrew year of this Hebrew date
   * @return {number}
   */
  _createClass(HDate, [{
    key: "getFullYear",
    value: function getFullYear() {
      return this.year;
    }

    /**
     * Tests if this date occurs during a leap year
     * @return {boolean}
     */
  }, {
    key: "isLeapYear",
    value: function isLeapYear$1() {
      return isLeapYear(this.year);
    }

    /**
     * Gets the Hebrew month (1=NISAN, 7=TISHREI) of this Hebrew date
     * @return {number}
     */
  }, {
    key: "getMonth",
    value: function getMonth() {
      return this.month;
    }

    /**
     * The Tishrei-based month of the date. 1 is Tishrei, 7 is Nisan, 13 is Elul in a leap year
     * @return {number}
     */
  }, {
    key: "getTishreiMonth",
    value: function getTishreiMonth() {
      var nummonths = monthsInYear(this.getFullYear());
      return (this.getMonth() + nummonths - 6) % nummonths || nummonths;
    }

    /**
     * Number of days in the month of this Hebrew date
     * @return {number}
     */
  }, {
    key: "daysInMonth",
    value: function daysInMonth$1() {
      return daysInMonth(this.getMonth(), this.getFullYear());
    }

    /**
     * Gets the day within the month (1-30)
     * @return {number}
     */
  }, {
    key: "getDate",
    value: function getDate() {
      return this.day;
    }

    /**
     * Gets the day of the week. 0=Sunday, 6=Saturday
     * @return {number}
     */
  }, {
    key: "getDay",
    value: function getDay() {
      return mod(this.abs(), 7);
    }

    /**
     * Sets the year of the date. Returns the object it was called upon.
     * @private
     * @deprecated
     * @param {number} year
     * @return {HDate}
     */
  }, {
    key: "setFullYear",
    value: function setFullYear(year) {
      this.year = year;
      fix(this);
      return this;
    }

    /**
     * Sets the day of the month of the date. Returns the object it was called upon
     * @private
     * @param {number} month
     * @return {HDate}
     */
  }, {
    key: "setMonth",
    value: function setMonth(month) {
      this.month = HDate.monthNum(month);
      fix(this);
      return this;
    }

    /**
     * @private
     * @param {number} date
     * @return {HDate}
     */
  }, {
    key: "setDate",
    value: function setDate(date) {
      this.day = date;
      fix(this);
      return this;
    }

    /**
     * Converts to Gregorian date
     * @return {Date}
     */
  }, {
    key: "greg",
    value: function greg() {
      return abs2greg(this.abs());
    }

    /**
     * Returns R.D. (Rata Die) fixed days.
     * R.D. 1 == Monday, January 1, 1 (Gregorian)
     * Note also that R.D. = Julian Date − 1,721,424.5
     * https://en.wikipedia.org/wiki/Rata_Die#Dershowitz_and_Reingold
     * @return {number}
     */
  }, {
    key: "abs",
    value: function abs() {
      if (typeof this.abs0 !== 'number') {
        this.abs0 = hebrew2abs(this.year, this.month, this.day);
      }
      return this.abs0;
    }

    /**
     * Converts Hebrew date to R.D. (Rata Die) fixed days.
     * R.D. 1 is the imaginary date Monday, January 1, 1 on the Gregorian
     * Calendar.
     * @param {number} year Hebrew year
     * @param {number} month Hebrew month
     * @param {number} day Hebrew date (1-30)
     * @return {number}
     */
  }, {
    key: "getMonthName",
    value:
    /**
     * Returns a transliterated Hebrew month name, e.g. `'Elul'` or `'Cheshvan'`.
     * @return {string}
     */
    function getMonthName$1() {
      return getMonthName(this.getMonth(), this.getFullYear());
    }

    /**
     * Renders this Hebrew date as a translated or transliterated string,
     * including ordinal e.g. `'15th of Cheshvan, 5769'`.
     * @example
     * import {HDate, months} from '@hebcal/core';
     *
     * const hd = new HDate(15, months.CHESHVAN, 5769);
     * console.log(hd.render('en')); // '15th of Cheshvan, 5769'
     * console.log(hd.render('he')); // '15 חֶשְׁוָן, 5769'
     * @param {string} [locale] Optional locale name (defaults to active locale).
     * @param {boolean} [showYear=true] Display year (defaults to true).
     * @return {string}
     */
  }, {
    key: "render",
    value: function render() {
      var locale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var showYear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var locale0 = locale || Locale.getLocaleName();
      var day = this.getDate();
      var monthName = Locale.gettext(this.getMonthName(), locale0);
      var nth = Locale.ordinal(day, locale0);
      var dayOf = HDate.getDayOfTranslation(locale0);
      var dateStr = "".concat(nth).concat(dayOf, " ").concat(monthName);
      if (showYear) {
        var fullYear = this.getFullYear();
        return "".concat(dateStr, ", ").concat(fullYear);
      } else {
        return dateStr;
      }
    }

    /**
     * @private
     * @param {string} locale
     * @return {string}
     */
  }, {
    key: "renderGematriya",
    value:
    /**
     * Renders this Hebrew date in Hebrew gematriya, regardless of locale.
     * @example
     * import {HDate, months} from '@hebcal/core';
     * const hd = new HDate(15, months.CHESHVAN, 5769);
     * console.log(hd.renderGematriya()); // 'ט״ו חֶשְׁוָן תשס״ט'
     * @param {boolean} [suppressNikud]
     * @return {string}
     */
    function renderGematriya() {
      var suppressNikud = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var d = this.getDate();
      var locale = suppressNikud ? 'he-x-NoNikud' : 'he';
      var m = Locale.gettext(this.getMonthName(), locale);
      var y = this.getFullYear();
      return gematriya(d) + ' ' + m + ' ' + gematriya(y);
    }

    /**
     * Returns an `HDate` representing the a dayNumber before the current date.
     * Sunday=0, Saturday=6
     * @example
     * new HDate(new Date('Wednesday February 19, 2014')).before(6).greg() // Sat Feb 15 2014
     * @param {number} day day of week
     * @return {HDate}
     */
  }, {
    key: "before",
    value: function before(day) {
      return _onOrBefore(day, this, -1);
    }

    /**
     * Returns an `HDate` representing the a dayNumber on or before the current date.
     * Sunday=0, Saturday=6
     * @example
     * new HDate(new Date('Wednesday February 19, 2014')).onOrBefore(6).greg() // Sat Feb 15 2014
     * new HDate(new Date('Saturday February 22, 2014')).onOrBefore(6).greg() // Sat Feb 22 2014
     * new HDate(new Date('Sunday February 23, 2014')).onOrBefore(6).greg() // Sat Feb 22 2014
     * @param {number} dow day of week
     * @return {HDate}
     */
  }, {
    key: "onOrBefore",
    value: function onOrBefore(dow) {
      return _onOrBefore(dow, this, 0);
    }

    /**
     * Returns an `HDate` representing the nearest dayNumber to the current date
     * Sunday=0, Saturday=6
     * @example
     * new HDate(new Date('Wednesday February 19, 2014')).nearest(6).greg() // Sat Feb 22 2014
     * new HDate(new Date('Tuesday February 18, 2014')).nearest(6).greg() // Sat Feb 15 2014
     * @param {number} dow day of week
     * @return {HDate}
     */
  }, {
    key: "nearest",
    value: function nearest(dow) {
      return _onOrBefore(dow, this, 3);
    }

    /**
     * Returns an `HDate` representing the a dayNumber on or after the current date.
     * Sunday=0, Saturday=6
     * @example
     * new HDate(new Date('Wednesday February 19, 2014')).onOrAfter(6).greg() // Sat Feb 22 2014
     * new HDate(new Date('Saturday February 22, 2014')).onOrAfter(6).greg() // Sat Feb 22 2014
     * new HDate(new Date('Sunday February 23, 2014')).onOrAfter(6).greg() // Sat Mar 01 2014
     * @param {number} dow day of week
     * @return {HDate}
     */
  }, {
    key: "onOrAfter",
    value: function onOrAfter(dow) {
      return _onOrBefore(dow, this, 6);
    }

    /**
     * Returns an `HDate` representing the a dayNumber after the current date.
     * Sunday=0, Saturday=6
     * @example
     * new HDate(new Date('Wednesday February 19, 2014')).after(6).greg() // Sat Feb 22 2014
     * new HDate(new Date('Saturday February 22, 2014')).after(6).greg() // Sat Mar 01 2014
     * new HDate(new Date('Sunday February 23, 2014')).after(6).greg() // Sat Mar 01 2014
     * @param {number} day day of week
     * @return {HDate}
     */
  }, {
    key: "after",
    value: function after(day) {
      return _onOrBefore(day, this, 7);
    }

    /**
     * Returns the next Hebrew date
     * @return {HDate}
     */
  }, {
    key: "next",
    value: function next() {
      return new HDate(this.abs() + 1);
    }

    /**
     * Returns the previous Hebrew date
     * @return {HDate}
     */
  }, {
    key: "prev",
    value: function prev() {
      return new HDate(this.abs() - 1);
    }

    /**
     * Returns a cloned `HDate` object with a specified amount of time added
     *
     * Units are case insensitive, and support plural and short forms.
     * Note, short forms are case sensitive.
     *
     * | Unit | Shorthand | Description
     * | --- | --- | --- |
     * | `day` | `d` | days |
     * | `week` | `w` | weeks |
     * | `month` | `M` | months |
     * | `year` | `y` | years |
     * @param {number} number
     * @param {string} [units]
     * @return {HDate}
     */
  }, {
    key: "add",
    value: function add(number) {
      var units = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
      number = parseInt(number, 10);
      if (!number) {
        return new HDate(this);
      }
      units = HDate.standardizeUnits(units);
      if (units === UNITS_DAY) {
        return new HDate(this.abs() + number);
      } else if (units === UNITS_WEEK) {
        return new HDate(this.abs() + 7 * number);
      } else if (units === UNITS_YEAR) {
        return new HDate(this.getDate(), this.getMonth(), this.getFullYear() + number);
      } else if (units === UNITS_MONTH) {
        var hd = new HDate(this);
        var sign = number > 0 ? 1 : -1;
        number = Math.abs(number);
        for (var i = 0; i < number; i++) {
          hd = new HDate(hd.abs() + sign * hd.daysInMonth());
        }
        return hd;
      }
    }

    /**
     * @private
     * @param {string} units
     * @return {string}
     */
  }, {
    key: "subtract",
    value:
    /**
     * Returns a cloned `HDate` object with a specified amount of time subracted
     *
     * Units are case insensitive, and support plural and short forms.
     * Note, short forms are case sensitive.
     *
     * | Unit | Shorthand | Description
     * | --- | --- | --- |
     * | `day` | `d` | days |
     * | `week` | `w` | weeks |
     * | `month` | `M` | months |
     * | `year` | `y` | years |
     * @example
     * import {HDate, months} from '@hebcal/core';
     *
     * const hd1 = new HDate(15, months.CHESHVAN, 5769);
     * const hd2 = hd1.add(1, 'weeks'); // 7 Kislev 5769
     * const hd3 = hd1.add(-3, 'M'); // 30 Av 5768
     * @param {number} number
     * @param {string} [units]
     * @return {HDate}
     */
    function subtract(number) {
      var units = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
      return this.add(number * -1, units);
    }

    /**
     * Returns the difference in days between the two given HDates.
     *
     * The result is positive if `this` date is comes chronologically
     * after the `other` date, and negative
     * if the order of the two dates is reversed.
     *
     * The result is zero if the two dates are identical.
     * @example
     * import {HDate, months} from '@hebcal/core';
     *
     * const hd1 = new HDate(25, months.KISLEV, 5770);
     * const hd2 = new HDate(15, months.CHESHVAN, 5769);
     * const days = hd1.deltaDays(hd2); // 394
     * @param {HDate} other Hebrew date to compare
     * @return {number}
     */
  }, {
    key: "deltaDays",
    value: function deltaDays(other) {
      if (!HDate.isHDate(other)) {
        throw new TypeError("Bad argument: ".concat(other));
      }
      return this.abs() - other.abs();
    }

    /**
     * Compares this date to another date, returning `true` if the dates match.
     * @param {HDate} other Hebrew date to compare
     * @return {boolean}
     */
  }, {
    key: "isSameDate",
    value: function isSameDate(other) {
      if (HDate.isHDate(other)) {
        return this.year == other.year && this.month == other.month && this.day == other.day;
      }
      return false;
    }

    /** @return {string} */
  }, {
    key: "toString",
    value: function toString() {
      var day = this.getDate();
      var fullYear = this.getFullYear();
      var monthName = this.getMonthName();
      return "".concat(day, " ").concat(monthName, " ").concat(fullYear);
    }

    /**
     * Returns true if Hebrew year is a leap year
     * @param {number} year Hebrew year
     * @return {boolean}
     */
  }], [{
    key: "hebrew2abs",
    value: function hebrew2abs$1(year, month, day) {
      return hebrew2abs(year, month, day);
    }

    /**
     * Converts absolute R.D. days to Hebrew date
     * @private
     * @param {number} abs absolute R.D. days
     * @return {SimpleHebrewDate}
     */
  }, {
    key: "abs2hebrew",
    value: function abs2hebrew$1(abs) {
      return abs2hebrew(abs);
    }
  }, {
    key: "getDayOfTranslation",
    value: function getDayOfTranslation(locale) {
      switch (locale) {
        case 'en':
        case 's':
        case 'a':
        case 'ashkenazi':
          return ' of';
      }
      var ofStr = Locale.lookupTranslation('of', locale);
      if (ofStr) {
        return ' ' + ofStr;
      }
      if ('ashkenazi' === locale.substring(0, 9)) {
        return ' of';
      }
      return '';
    }
  }, {
    key: "standardizeUnits",
    value: function standardizeUnits(units) {
      var full = UNITS_SINGLE[units] || String(units || '').toLowerCase().replace(/s$/, '');
      return UNITS_VALID[full] || throwTypeError("Invalid units '".concat(units, "'"));
    }
  }, {
    key: "isLeapYear",
    value: function isLeapYear$1(year) {
      return isLeapYear(year);
    }

    /**
     * Number of months in this Hebrew year (either 12 or 13 depending on leap year)
     * @param {number} year Hebrew year
     * @return {number}
     */
  }, {
    key: "monthsInYear",
    value: function monthsInYear$1(year) {
      return monthsInYear(year);
    }

    /**
     * Number of days in Hebrew month in a given year (29 or 30)
     * @param {number} month Hebrew month (e.g. months.TISHREI)
     * @param {number} year Hebrew year
     * @return {number}
     */
  }, {
    key: "daysInMonth",
    value: function daysInMonth$1(month, year) {
      return daysInMonth(month, year);
    }

    /**
     * Returns a transliterated string name of Hebrew month in year,
     * for example 'Elul' or 'Cheshvan'.
     * @param {number} month Hebrew month (e.g. months.TISHREI)
     * @param {number} year Hebrew year
     * @return {string}
     */
  }, {
    key: "getMonthName",
    value: function getMonthName$1(month, year) {
      return getMonthName(month, year);
    }

    /**
     * Returns the Hebrew month number (NISAN=1, TISHREI=7)
     * @param {number|string} month A number, or Hebrew month name string
     * @return {number}
     */
  }, {
    key: "monthNum",
    value: function monthNum(month) {
      if (typeof month === 'number') {
        if (isNaN(month) || month > 14) {
          throw new RangeError("Invalid month number: ".concat(month));
        }
        return month;
      }
      return month.charCodeAt(0) >= 48 && month.charCodeAt(0) <= 57 ? /* number */
      parseInt(month, 10) : HDate.monthFromName(month);
    }

    /**
     * Number of days in the hebrew YEAR
     * @param {number} year Hebrew year
     * @return {number}
     */
  }, {
    key: "daysInYear",
    value: function daysInYear$1(year) {
      return daysInYear(year);
    }

    /**
     * true if Cheshvan is long in Hebrew year
     * @param {number} year Hebrew year
     * @return {boolean}
     */
  }, {
    key: "longCheshvan",
    value: function longCheshvan$1(year) {
      return longCheshvan(year);
    }

    /**
     * true if Kislev is short in Hebrew year
     * @param {number} year Hebrew year
     * @return {boolean}
     */
  }, {
    key: "shortKislev",
    value: function shortKislev$1(year) {
      return shortKislev(year);
    }

    /**
     * Converts Hebrew month string name to numeric
     * @param {string} monthName monthName
     * @return {number}
     */
  }, {
    key: "monthFromName",
    value: function monthFromName(monthName) {
      if (typeof monthName === 'number') {
        if (isNaN(monthName) || monthName < 1 || monthName > 14) {
          throw new RangeError("Invalid month name: ".concat(monthName));
        }
        return monthName;
      }
      var c = monthName.toLowerCase();
      /*
      the Hebrew months are unique to their second letter
      N         Nisan  (November?)
      I         Iyyar
      E        Elul
      C        Cheshvan
      K        Kislev
      1        1Adar
      2        2Adar
      Si Sh     Sivan, Shvat
      Ta Ti Te Tamuz, Tishrei, Tevet
      Av Ad    Av, Adar
       אב אד אי אל   אב אדר אייר אלול
      ח            חשון
      ט            טבת
      כ            כסלו
      נ            ניסן
      ס            סיון
      ש            שבט
      תמ תש        תמוז תשרי
      */
      switch (c[0]) {
        case 'n':
        case 'נ':
          if (c[1] == 'o') {
            break; /* this catches "november" */
          }

          return months.NISAN;
        case 'i':
          return months.IYYAR;
        case 'e':
          return months.ELUL;
        case 'c':
        case 'ח':
          return months.CHESHVAN;
        case 'k':
        case 'כ':
          return months.KISLEV;
        case 's':
          switch (c[1]) {
            case 'i':
              return months.SIVAN;
            case 'h':
              return months.SHVAT;
          }
        case 't':
          switch (c[1]) {
            case 'a':
              return months.TAMUZ;
            case 'i':
              return months.TISHREI;
            case 'e':
              return months.TEVET;
          }
          break;
        case 'a':
          switch (c[1]) {
            case 'v':
              return months.AV;
            case 'd':
              if (/(1|[^i]i|a|א)$/i.test(monthName)) {
                return months.ADAR_I;
              }
              return months.ADAR_II;
            // else assume sheini
          }

          break;
        case 'ס':
          return months.SIVAN;
        case 'ט':
          return months.TEVET;
        case 'ש':
          return months.SHVAT;
        case 'א':
          switch (c[1]) {
            case 'ב':
              return months.AV;
            case 'ד':
              if (/(1|[^i]i|a|א)$/i.test(monthName)) {
                return months.ADAR_I;
              }
              return months.ADAR_II;
            // else assume sheini
            case 'י':
              return months.IYYAR;
            case 'ל':
              return months.ELUL;
          }
          break;
        case 'ת':
          switch (c[1]) {
            case 'מ':
              return months.TAMUZ;
            case 'ש':
              return months.TISHREI;
          }
          break;
      }
      throw new RangeError("Unable to parse month name: ".concat(monthName));
    }

    /**
     * Note: Applying this function to d+6 gives us the DAYNAME on or after an
     * absolute day d. Similarly, applying it to d+3 gives the DAYNAME nearest to
     * absolute date d, applying it to d-1 gives the DAYNAME previous to absolute
     * date d, and applying it to d+7 gives the DAYNAME following absolute date d.
     * @param {number} dayOfWeek
     * @param {number} absdate
     * @return {number}
     */
  }, {
    key: "dayOnOrBefore",
    value: function dayOnOrBefore(dayOfWeek, absdate) {
      return absdate - (absdate - dayOfWeek) % 7;
    }

    /**
     * Tests if the object is an instance of `HDate`
     * @param {any} obj
     * @return {boolean}
     */
  }, {
    key: "isHDate",
    value: function isHDate(obj) {
      return obj !== null && _typeof(obj) === 'object' && typeof obj.year === 'number' && typeof obj.month === 'number' && typeof obj.day === 'number' && typeof obj.greg === 'function' && typeof obj.abs === 'function';
    }
  }]);
  return HDate;
}();

/**
 * @private
 * @param {HDate} date
 */
function fix(date) {
  fixMonth(date);
  fixDate(date);
}

/**
 * @private
 * @param {HDate} date
 */
function fixDate(date) {
  if (date.day < 1) {
    if (date.month == months.TISHREI) {
      date.year -= 1;
    }
    date.day += daysInMonth(date.month, date.year);
    date.month -= 1;
    fix(date);
  }
  if (date.day > daysInMonth(date.month, date.year)) {
    if (date.month === months.ELUL) {
      date.year += 1;
    }
    date.day -= daysInMonth(date.month, date.year);
    date.month += 1;
    fix(date);
  }
  fixMonth(date);
}

/**
 * @private
 * @param {HDate} date
 */
function fixMonth(date) {
  if (date.month === months.ADAR_II && !date.isLeapYear()) {
    date.month -= 1; // to Adar I
    fix(date);
  } else if (date.month < 1) {
    date.month += monthsInYear(date.year);
    date.year -= 1;
    fix(date);
  } else if (date.month > monthsInYear(date.year)) {
    date.month -= monthsInYear(date.year);
    date.year += 1;
    fix(date);
  }
  delete date.abs0;
}

/**
 * @private
 * @param {number} day
 * @param {HDate} t
 * @param {number} offset
 * @return {HDate}
 */
function _onOrBefore(day, t, offset) {
  return new HDate(HDate.dayOnOrBefore(day, t.abs() + offset));
}

var NISAN = months.NISAN;
var CHESHVAN = months.CHESHVAN;
var KISLEV = months.KISLEV;
var TEVET = months.TEVET;
var SHVAT = months.SHVAT;
var ADAR_I = months.ADAR_I;
var ADAR_II = months.ADAR_II;

/**
 * @private
 * @param {number} hyear Hebrew year
 * @param {Date|HDate} gdate Gregorian or Hebrew date of death
 * @return {HDate} anniversary occurring in hyear
 */
function getYahrzeit_(hyear, gdate) {
  var orig = HDate.isHDate(gdate) ? gdate : new HDate(gdate);
  var hDeath = {
    yy: orig.getFullYear(),
    mm: orig.getMonth(),
    dd: orig.getDate()
  };
  if (hyear <= hDeath.yy) {
    // `Hebrew year ${hyear} occurs on or before original date in ${hDeath.yy}`
    return undefined;
  }
  if (hDeath.mm == CHESHVAN && hDeath.dd == 30 && !longCheshvan(hDeath.yy + 1)) {
    // If it's Heshvan 30 it depends on the first anniversary;
    // if that was not Heshvan 30, use the day before Kislev 1.
    hDeath = abs2hebrew(hebrew2abs(hyear, KISLEV, 1) - 1);
  } else if (hDeath.mm == KISLEV && hDeath.dd == 30 && shortKislev(hDeath.yy + 1)) {
    // If it's Kislev 30 it depends on the first anniversary;
    // if that was not Kislev 30, use the day before Teveth 1.
    hDeath = abs2hebrew(hebrew2abs(hyear, TEVET, 1) - 1);
  } else if (hDeath.mm == ADAR_II) {
    // If it's Adar II, use the same day in last month of year (Adar or Adar II).
    hDeath.mm = monthsInYear(hyear);
  } else if (hDeath.mm == ADAR_I && hDeath.dd == 30 && !isLeapYear(hyear)) {
    // If it's the 30th in Adar I and year is not a leap year
    // (so Adar has only 29 days), use the last day in Shevat.
    hDeath.dd = 30;
    hDeath.mm = SHVAT;
  }
  // In all other cases, use the normal anniversary of the date of death.

  // advance day to rosh chodesh if needed
  if (hDeath.mm == CHESHVAN && hDeath.dd == 30 && !longCheshvan(hyear)) {
    hDeath.mm = KISLEV;
    hDeath.dd = 1;
  } else if (hDeath.mm == KISLEV && hDeath.dd == 30 && shortKislev(hyear)) {
    hDeath.mm = TEVET;
    hDeath.dd = 1;
  }
  return new HDate(hDeath.dd, hDeath.mm, hyear);
}

/**
 * @private
 * @param {number} hyear Hebrew year
 * @param {Date|HDate} gdate Gregorian or Hebrew date of event
 * @return {HDate} anniversary occurring in `hyear`
 */
function getBirthdayOrAnniversary_(hyear, gdate) {
  var orig = HDate.isHDate(gdate) ? gdate : new HDate(gdate);
  var origYear = orig.getFullYear();
  if (hyear === origYear) {
    return orig;
  } else if (hyear < origYear) {
    // `Hebrew year ${hyear} occurs on or before original date in ${origYear}`
    return undefined;
  }
  var isOrigLeap = isLeapYear(origYear);
  var month = orig.getMonth();
  var day = orig.getDate();
  if (month == ADAR_I && !isOrigLeap || month == ADAR_II && isOrigLeap) {
    month = monthsInYear(hyear);
  } else if (month == CHESHVAN && day == 30 && !longCheshvan(hyear)) {
    month = KISLEV;
    day = 1;
  } else if (month == KISLEV && day == 30 && shortKislev(hyear)) {
    month = TEVET;
    day = 1;
  } else if (month == ADAR_I && day == 30 && isOrigLeap && !isLeapYear(hyear)) {
    month = NISAN;
    day = 1;
  }
  return new HDate(day, month, hyear);
}

var version="4.1.1";

var headers={"plural-forms":"nplurals=2; plural=(n > 1);"};var contexts={"":{Adar:["אַדָר"],"Adar I":["אַדָר א׳"],"Adar II":["אַדָר ב׳"],Av:["אָב"],Cheshvan:["חֶשְׁוָן"],Elul:["אֱלוּל"],Iyyar:["אִיָיר"],Kislev:["כִּסְלֵו"],Nisan:["נִיסָן"],"Sh'vat":["שְׁבָט"],Sivan:["סִיוָן"],Tamuz:["תַּמּוּז"],Tevet:["טֵבֵת"],Tishrei:["תִשְׁרֵי"]}};var poHeMin = {headers:headers,contexts:contexts};

Locale.addLocale('he', poHeMin);
Locale.addLocale('h', poHeMin);
var heStrs = poHeMin.contexts[''];
var heNoNikud = {};
Object.keys(heStrs).forEach(function (key) {
  heNoNikud[key] = [Locale.hebrewStripNikkud(heStrs[key][0])];
});
Locale.addLocale('he-x-NoNikud', {
  headers: poHeMin.headers,
  contexts: {
    '': heNoNikud
  }
});

exports.HDate = HDate;
exports.Locale = Locale;
exports.gematriya = gematriya;
exports.getBirthdayOrAnniversary = getBirthdayOrAnniversary_;
exports.getYahrzeit = getYahrzeit_;
exports.greg = greg;
exports.months = months;
exports.version = version;

return exports;

})({});
